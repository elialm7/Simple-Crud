package com.roelias.crud;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Abstract CRUD base class providing automatic SQL generation and type transformations.
 * <p>
 * This class uses annotation-driven configuration to automatically generate INSERT, UPDATE,
 * SELECT, and DELETE statements based on entity class definitions. It supports various
 * data type transformations including JSON serialization, array handling, enum storage,
 * UUID generation, and automatic timestamp management.
 * </p>
 *
 * <h3>Key Features:</h3>
 * <ul>
 *   <li>Zero-configuration CRUD operations</li>
 *   <li>Automatic SQL generation based on annotations</li>
 *   <li>Type transformations (JSON, Arrays, Enums, UUIDs)</li>
 *   <li>Automatic timestamp handling for audit fields</li>
 *   <li>Performance optimization through metadata caching</li>
 *   <li>Full transaction support with isolation levels</li>
 *   <li>Batch operations for high-performance inserts</li>
 * </ul>
 *
 * <h3>Usage Example:</h3>
 * <pre>{@code
 * @Table("users")
 * public class User {
 *     @Id(autoGenerated = true)
 *     private Long id;
 *
 *     @Column("user_name")
 *     private String name;
 *
 *     @CreatedDate
 *     private LocalDateTime createdAt;
 * }
 *
 * public class UserCRUD extends CRUD<User, Long> {
 *     public UserCRUD(Jdbi jdbi) {
 *         super(jdbi, User.class, Long.class);
 *     }
 * }
 * }</pre>
 *
 * @param <E> The entity type
 * @param <ID> The primary key type
 * @author Your Name
 * @version 1.0
 * @since 1.0
 */
public abstract class CRUD<E, ID> {

    protected final Jdbi jdbi;
    protected final String tableName;
    private final Class<E> entityClass;
    private final Class<ID> idType;
    private Dialect dialect;
    private static final ObjectMapper objectMapper = new ObjectMapper();

    // ================================
    // ANNOTATIONS
    // ================================

    public enum Dialect{
        MYSQL,
        POSTGRESQL
    }

    /**
     * Marks a class as a database table entity.
     * <p>
     * This annotation is required on all entity classes to specify the table name
     * and optionally the schema name.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Table {
        /**
         * The table name in the database.
         * @return table name
         */
        String value();

        /**
         * The schema name (optional). If provided, queries will use schema.table format.
         * @return schema name, empty string if not specified
         */
        String schema() default "";

        Dialect dialect() default Dialect.MYSQL;
    }

    /**
     * Maps a field to a specific database column name.
     * <p>
     * If not specified, the field name will be used as the column name.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Column {
        /**
         * The column name in the database.
         * @return column name, or empty string to use field name
         */
        String value() default "";
    }

    /**
     * Marks a field as the primary key.
     * <p>
     * Only one field per entity should have this annotation.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Id {
        /**
         * Whether the ID is auto-generated by the database.
         * <p>
         * If true, the field will be excluded from INSERT statements and the generated
         * key will be returned. If false, you must provide the ID value before saving.
         * </p>
         *
         * @return true if auto-generated, false if manually provided
         */
        boolean autoGenerated() default true;
    }

    /**
     * Marks a String field for automatic UUID generation.
     * <p>
     * A random UUID will be generated and assigned to the field if it's null
     * during save operations.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UUID {
        /**
         * Whether to automatically generate UUIDs for null fields.
         * @return true to auto-generate, false to leave null fields as-is
         */
        boolean autoGenerate() default true;
    }

    /**
     * Marks a field for JSON serialization/deserialization.
     * <p>
     * The field value will be automatically serialized to JSON string when saving
     * and can be deserialized when loading. Supports Objects, Maps, Lists, and JsonNode.
     * </p>
     *
     * <h4>Supported Types:</h4>
     * <ul>
     *   <li>Custom Objects - Serialized using Jackson ObjectMapper</li>
     *   <li>Map&lt;String,Object&gt; - For dynamic key-value data</li>
     *   <li>JsonNode - For raw JSON manipulation</li>
     *   <li>Lists and Arrays of objects</li>
     * </ul>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface JsonColumn {
    }

    /**
     * Marks a field for array serialization using a separator.
     * <p>
     * List&lt;String&gt; and String[] fields will be joined into a single string
     * using the specified separator for database storage.
     * </p>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * @ArrayColumn(separator = ",")
     * private List<String> tags; // Stored as "tag1,tag2,tag3"
     *
     * @ArrayColumn(separator = "|")
     * private String[] categories; // Stored as "cat1|cat2|cat3"
     * }</pre>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ArrayColumn {
        /**
         * The separator used to join array elements.
         * @return separator string, defaults to comma
         */
        String separator() default ",";
    }

    /**
     * Marks a byte[] field as file storage.
     * <p>
     * This is a marker annotation for documentation purposes. The field will be
     * stored as BLOB/BYTEA in the database.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface FileColumn {
    }

    /**
     * Marks a field to be ignored during database operations.
     * <p>
     * Fields with this annotation will not be included in INSERT or UPDATE statements.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Ignore {
    }

    /**
     * Marks a LocalDateTime field for automatic creation timestamp.
     * <p>
     * The field will be automatically set to the current timestamp when the entity
     * is saved for the first time. This field is excluded from UPDATE statements.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface CreatedDate {
    }

    /**
     * Marks a LocalDateTime field for automatic update timestamp.
     * <p>
     * The field will be automatically set to the current timestamp whenever the
     * entity is saved or updated.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UpdatedDate {
    }

    /**
     * Specifies a default value for a field.
     * <p>
     * If the field is null during save operations, it will be set to the specified
     * default value. The value is automatically converted to the field's type.
     * </p>
     *
     * <h4>Supported Types:</h4>
     * <ul>
     *   <li>String</li>
     *   <li>Integer/int</li>
     *   <li>Long/long</li>
     *   <li>Boolean/boolean</li>
     *   <li>Double/double</li>
     * </ul>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Default {
        /**
         * The default value as a string (will be converted to field type).
         * @return default value
         */
        String value();
    }

    /**
     * Configures enum field storage strategy.
     * <p>
     * Determines how enum values are stored in the database.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface EnumColumn {
        /**
         * The enum storage strategy.
         * @return the enum type strategy
         */
        EnumType value() default EnumType.STRING;

        /**
         * Enum storage strategies.
         */
        enum EnumType {
            /**
             * Store enum as string using name() method (e.g., "ACTIVE", "INACTIVE").
             * <p>
             * <strong>Pros:</strong> Human-readable, refactor-safe<br>
             * <strong>Cons:</strong> Larger storage size
             * </p>
             */
            STRING,

            /**
             * Store enum as integer using ordinal() method (e.g., 0, 1, 2).
             * <p>
             * <strong>Pros:</strong> Compact storage<br>
             * <strong>Cons:</strong> Fragile to enum reordering
             * </p>
             */
            ORDINAL,

            /**
             * Store enum using custom getCode() method.
             * <p>
             * The enum must implement a getCode() method that returns a String or primitive.
             * <strong>Example:</strong>
             * <pre>{@code
             * public enum Status {
             *     ACTIVE("ACT"), INACTIVE("INA");
             *     private final String code;
             *     Status(String code) { this.code = code; }
             *     public String getCode() { return code; }
             * }
             * }</pre>
             * </p>
             */
            CODE
        }
    }

    // Performance optimization caches
    private static final Map<Class<?>, String> tableNameCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field[]> insertableFieldsCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field[]> updatableFieldsCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field> idFieldCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, String> insertSqlCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, String> updateSqlCache = new ConcurrentHashMap<>();
    /**
     * Creates a new CRUD instance for the specified entity.
     * <p>
     * The table name is automatically extracted from the @Table annotation on the entity class.
     * </p>
     *
     * @param jdbi the JDBI instance for database operations
     * @param entityClass the entity class (must be annotated with @Table)
     * @param idType the primary key type
     * @throws IllegalArgumentException if the entity class is not annotated with @Table
     */
    public CRUD(Jdbi jdbi, Class<E> entityClass, Class<ID> idType) {
        this.jdbi = jdbi;
        this.entityClass = entityClass;
        this.idType = idType;
        this.tableName = extractTableName();
    }

    /**
     * Extracts the table name from the @Table annotation.
     *
     * @return the full table name (schema.table or just table)
     * @throws IllegalArgumentException if @Table annotation is missing
     */
    private String extractTableName() {
        return tableNameCache.computeIfAbsent(entityClass, clazz -> {
            Table tableAnnotation = clazz.getAnnotation(Table.class);
            if (tableAnnotation == null) {
                throw new IllegalArgumentException(
                        "Entity " + clazz.getName() + " must be annotated with @Table"
                );
            }

            String schema = tableAnnotation.schema();
            String table = tableAnnotation.value();
            dialect = tableAnnotation.dialect();
            return schema.isEmpty() ? table : schema + "." + table;
        });

    }

    /**
     * Gets the database column name for the ID field.
     *
     * @return the ID column name
     */
    protected String getIdColumnName() {
        Field idField = getIdField();
        Column column = idField.getAnnotation(Column.class);
        return column != null && !column.value().isEmpty() ? column.value() : idField.getName();
    }

    /**
     * Gets the ID type class.
     *
     * @return the ID type class
     */
    protected Class<ID> getIdType() {
        return idType;
    }

    /**
     * Creates a RowMapper for automatic result set mapping.
     * <p>
     * Override this method to provide custom mapping logic if needed.
     * </p>
     *
     * @return the row mapper for this entity type
     */
    protected org.jdbi.v3.core.mapper.RowMapper<E> getRowMapper() {
      //  return BeanMapper.of(entityClass);
         return (rs, ctx) -> mapRow(rs, entityClass);
    }


    /**
     * Creates a RowMapper for any class that uses CRUD field annotations.
     * <p>
     * Reuses the same mapping logic for DTOs, custom result classes, or joined queries.
     * No @Table annotation required - only field-level annotations are used.
     * </p>
     *
     * <h4>Example Usage:</h4>
     * <pre>{@code
     * // DTO class - NO necesita @Table!
     * public class UsuarioDetalles {
     *     @Column("user_name")
     *     private String nombre;
     *
     *     @Column("role_name")
     *     private String rol;
     *
     *     @JsonColumn
     *     private Map<String, Object> metadata;
     * }
     *
     * // En tu repositorio
     * public List<UsuarioDetalles> findUserDetails() {
     *     return jdbi.withHandle(handle ->
     *         handle.createQuery("SELECT u.name as user_name, r.name as role_name, u.metadata FROM users u JOIN roles r ON u.role_id = r.id")
     *         .map(getCustomRowMapper(UsuarioDetalles.class)) // ✅ Funciona sin @Table
     *         .list()
     *     );
     * }
     * }</pre>
     *
     * @param <T> the target class type
     * @param targetClass the class to map results to (must have a no-arg constructor)
     * @return a RowMapper instance for the target class
     */
    public <T> org.jdbi.v3.core.mapper.RowMapper<T> getCustomRowMapper(Class<T> targetClass) {
        return (rs, ctx) -> mapRow(rs, targetClass);
    }



    // ================================
    // AUTOMATIC SQL GENERATION
    // ================================

    /**
     * Builds the INSERT SQL statement for this entity.
     * <p>
     * The SQL is generated based on entity annotations and cached for performance.
     * Only non-ignored fields and non-auto-generated ID fields are included.
     * </p>
     *
     * @return the INSERT SQL statement
     */
    protected String buildInsertSql() {
        return insertSqlCache.computeIfAbsent(entityClass, clazz -> {
            Field[] fields = getInsertableFields();

            StringJoiner columns = new StringJoiner(", ");
            StringJoiner placeholders = new StringJoiner(", ");

            for (Field field : fields) {
                String columnName = getColumnName(field);
                columns.add(columnName);
                String placeholder = ":" + field.getName();

                // Si el dialecto es PostgreSQL y es un JSON column, agregamos ::jsonb
                if (dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(JsonColumn.class)) {
                    placeholder += "::jsonb";
                }
                if(dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(UUID.class)) {
                    UUID uuidAnnotation = field.getAnnotation(UUID.class);
                    if(!uuidAnnotation.autoGenerate()){
                        placeholder += "::uuid";
                    }
                }

                placeholders.add(placeholder);
            }

            return "INSERT INTO " + tableName + " (" + columns + ") VALUES (" + placeholders + ")";
        });
    }

    /**
     * Builds the UPDATE SQL statement for this entity.
     * <p>
     * The SQL is generated based on entity annotations and cached for performance.
     * CreatedDate fields are excluded from updates, but UpdatedDate fields are included.
     * </p>
     *
     * @return the UPDATE SQL statement
     */
    protected String buildUpdateSql() {
        return updateSqlCache.computeIfAbsent(entityClass, clazz -> {
            Field[] fields = getUpdatableFields();
            Field idField = getIdField();

            StringJoiner setClauses = new StringJoiner(", ");

            for (Field field : fields) {
                if (!field.equals(idField) && !field.isAnnotationPresent(CreatedDate.class)) {
                    String columnName = getColumnName(field);
                    String placeholder = ":" + field.getName();

                    if (dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(JsonColumn.class)) {
                        placeholder += "::jsonb";
                    }

                    if (dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(UUID.class)) {
                        UUID uuidAnnotation = field.getAnnotation(UUID.class);
                        if (!uuidAnnotation.autoGenerate()) {
                            placeholder += "::uuid";
                        }
                    }

                    setClauses.add(columnName + " = " + placeholder);
                }
            }

            return "UPDATE " + tableName + " SET " + setClauses + " WHERE " + getIdColumnName() + " = :" + idField.getName();
        });
    }

    // ================================
    // AUTOMATIC PARAMETER BINDING WITH TRANSFORMATIONS
    // ================================

    /**
     * Binds parameters for INSERT operations with automatic transformations.
     * <p>
     * Processes the entity by generating UUIDs, setting defaults, and timestamps
     * before binding parameters to the statement.
     * </p>
     *
     * @param update the JDBI Update statement
     * @param entity the entity to bind
     */
    protected void bindInsertParameters(Update update, E entity) {
        processEntityForInsert(entity);
        bindParameters(update, entity, getInsertableFields());
    }

    /**
     * Binds parameters for UPDATE operations with automatic transformations.
     * <p>
     * Processes the entity by updating timestamps before binding parameters.
     * </p>
     *
     * @param update the JDBI Update statement
     * @param entity the entity to bind
     */
    protected void bindUpdateParameters(Update update, E entity) {
        processEntityForUpdate(entity);
        bindParameters(update, entity, getAllFields());
    }

    /**
     * Binds parameters for BATCH operations with automatic transformations.
     *
     * @param batch the JDBI PreparedBatch statement
     * @param entity the entity to bind
     */
    protected void bindBatchParameters(PreparedBatch batch, E entity) {
        processEntityForInsert(entity);
        bindParameters(batch, entity, getInsertableFields());
    }

    /**
     * Binds field values to statement parameters with type transformations.
     *
     * @param statement the JDBI statement (Update or PreparedBatch)
     * @param entity the entity containing values
     * @param fields the fields to bind
     */
    private void bindParameters(Object statement, E entity, Field[] fields) {
        for (Field field : fields) {
            try {
                field.setAccessible(true);
                Object value = field.get(entity);
                Object processedValue = processFieldValue(field, value);

                if (statement instanceof Update) {
                    ((Update) statement).bind(field.getName(), processedValue);
                } else if (statement instanceof PreparedBatch) {
                    ((PreparedBatch) statement).bind(field.getName(), processedValue);
                }
            } catch (IllegalAccessException e) {
                throw new RuntimeException("Error accessing field: " + field.getName(), e);
            }
        }
    }

    // ================================
    // AUTOMATIC FIELD PROCESSING
    // ================================

    /**
     * Processes entity fields before INSERT operations.
     * <p>
     * Performs the following operations in order:
     * <ol>
     *   <li>Generate UUIDs for @UUID annotated fields</li>
     *   <li>Set default values for @Default annotated fields</li>
     *   <li>Set timestamps for @CreatedDate and @UpdatedDate fields</li>
     * </ol>
     * </p>
     *
     * @param entity the entity to process
     */
    private void processEntityForInsert(E entity) {
        generateUUIDs(entity);
        setDefaultValues(entity);
        setTimestamp(entity, CreatedDate.class);
        setTimestamp(entity, UpdatedDate.class);
    }

    /**
     * Processes entity fields before UPDATE operations.
     * <p>
     * Only updates @UpdatedDate fields with the current timestamp.
     * </p>
     *
     * @param entity the entity to process
     */
    private void processEntityForUpdate(E entity) {
        setTimestamp(entity, UpdatedDate.class);
    }

    /**
     * Generates UUIDs for @UUID annotated fields that are null.
     *
     * @param entity the entity to process
     */
    private void generateUUIDs(E entity) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(UUID.class))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        Object currentValue = field.get(entity);

                        if (currentValue == null) {
                            UUID uuidAnnotation = field.getAnnotation(UUID.class);
                            if (uuidAnnotation.autoGenerate()) {
                                if(field.getType() == String.class){
                                    field.set(entity, java.util.UUID.randomUUID().toString());
                                }else if(field.getType() == java.util.UUID.class){
                                    field.set(entity, java.util.UUID.randomUUID());
                                }
                            }
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error generating UUID for field: " + field.getName(), e);
                    }
                });
    }

    /**
     * Sets default values for @Default annotated fields that are null.
     *
     * @param entity the entity to process
     */
    private void setDefaultValues(E entity) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(Default.class))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        Object currentValue = field.get(entity);

                        if (currentValue == null) {
                            Default defaultAnnotation = field.getAnnotation(Default.class);
                            Object defaultValue = convertStringToFieldType(defaultAnnotation.value(), field.getType());
                            field.set(entity, defaultValue);
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error setting default value for field: " + field.getName(), e);
                    }
                });
    }

    /**
     * Sets timestamp fields with the current LocalDateTime.
     *
     * @param entity the entity to process
     * @param annotationClass the timestamp annotation class (CreatedDate or UpdatedDate)
     */
    private void setTimestamp(E entity, Class<? extends java.lang.annotation.Annotation> annotationClass) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(annotationClass))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        if (field.getType() == LocalDateTime.class) {
                            field.set(entity, LocalDateTime.now());
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error setting timestamp for field: " + field.getName(), e);
                    }
                });
    }

    // ================================
    // TYPE TRANSFORMATIONS
    // ================================

    /**
     * Processes field values with type-specific transformations.
     * <p>
     * Handles the following transformations:
     * <ul>
     *   <li>@JsonColumn: Serializes objects to JSON strings</li>
     *   <li>@ArrayColumn: Joins arrays/lists with specified separator</li>
     *   <li>@EnumColumn: Converts enums based on storage strategy</li>
     * </ul>
     * </p>
     *
     * @param field the field being processed
     * @param value the field value
     * @return the transformed value for database storage
     */
    private Object processFieldValue(Field field, Object value) {
        if (value == null) return null;

        // JSON Column serialization
        if (field.isAnnotationPresent(JsonColumn.class) && !(value instanceof String)) {
            try {
                return objectMapper.writeValueAsString(value);
            } catch (Exception e) {
                throw new RuntimeException("Error serializing JSON field: " + field.getName(), e);
            }
        }

        // Array Column joining
        if (field.isAnnotationPresent(ArrayColumn.class)) {
            ArrayColumn arrayAnnotation = field.getAnnotation(ArrayColumn.class);
            if (value instanceof List) {
                return String.join(arrayAnnotation.separator(),
                        ((List<?>) value).stream().map(Object::toString).toArray(String[]::new));
            } else if (value instanceof String[]) {
                return String.join(arrayAnnotation.separator(), (String[]) value);
            }
        }

        // Enum Column transformation
        if (field.isAnnotationPresent(EnumColumn.class) && value instanceof Enum) {
            EnumColumn enumAnnotation = field.getAnnotation(EnumColumn.class);
            Enum<?> enumValue = (Enum<?>) value;
            switch (enumAnnotation.value()) {
                case STRING:
                    return enumValue.name();
                case ORDINAL:
                    return enumValue.ordinal();
                case CODE:
                    try {
                        Method getCodeMethod = enumValue.getClass().getMethod("getCode");
                        return getCodeMethod.invoke(enumValue);
                    } catch (Exception e) {
                        throw new IllegalStateException(
                                "The enum " + enumValue.getClass().getName() +
                                        " must have a getCode() method for @EnumColumn(EnumType.CODE)", e
                        );
                    }
                default:
                    return enumValue.ordinal();
            }
        }

        return value;
    }

    // ================================
    // REFLECTION UTILITIES WITH CACHING
    // ================================

    /**
     * Gets fields that should be included in INSERT statements.
     * <p>
     * Excludes @Ignore fields and auto-generated @Id fields.
     * Results are cached for performance.
     * </p>
     *
     * @return array of insertable fields
     */
    private Field[] getInsertableFields() {
        return insertableFieldsCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> !field.isAnnotationPresent(Ignore.class))
                        .filter(field -> {
                            Id idAnnotation = field.getAnnotation(Id.class);
                            return idAnnotation == null || !idAnnotation.autoGenerated();
                        })
                        .toArray(Field[]::new)
        );
    }

    /**
     * Gets fields that should be included in UPDATE statements.
     * <p>
     * Excludes only @Ignore fields. Results are cached for performance.
     * </p>
     *
     * @return array of updatable fields
     */
    private Field[] getUpdatableFields() {
        return updatableFieldsCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> !field.isAnnotationPresent(Ignore.class))
                        .toArray(Field[]::new)
        );
    }

    /**
     * Gets all declared fields of the entity class.
     *
     * @return array of all fields
     */
    private Field[] getAllFields() {
        return entityClass.getDeclaredFields();
    }

    /**
     * Gets the @Id annotated field from the entity class.
     * <p>
     * Results are cached for performance.
     * </p>
     *
     * @return the ID field
     * @throws RuntimeException if no @Id field is found
     */
    private Field getIdField() {
        return idFieldCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> field.isAnnotationPresent(Id.class))
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("No @Id field found in " + clazz.getName()))
        );
    }

    /**
     * Gets the database column name for a field.
     * <p>
     * Uses @Column annotation value if present, otherwise uses field name.
     * </p>
     *
     * @param field the field to get column name for
     * @return the column name
     */
    private String getColumnName(Field field) {
        Column column = field.getAnnotation(Column.class);
        return column != null && !column.value().isEmpty() ? column.value() : field.getName();
    }
    // ================================

    // FILTERING EXTENSIONS
    // ================================

    private static final Set<String> RESERVED_KEYWORDS = Set.of(
            "page", "size", "limit", "offset", "sortBy", "sortOrder"
    );


    public enum FilterOperator {
        EQUALS("="),
        NOT_EQUALS("!="),
        GREATER_THAN(">"),
        LESS_THAN("<"),
        GREATER_THAN_OR_EQUAL(">="),
        LESS_THAN_OR_EQUAL("<="),
        LIKE("LIKE"),
        NOT_LIKE("NOT LIKE"),
        STARTS_WITH("LIKE"),  // Usa LIKE en SQL, pero con patrón 'value%'
        ENDS_WITH("LIKE");
        private final String sqlOperator;

        FilterOperator(String sqlOperator) {
            this.sqlOperator = sqlOperator;
        }

        public String getSqlOperator() {
            return sqlOperator;
        }
    }

    private static class FilterCondition {
        private final String fieldName;
        private final FilterOperator operator;
        private final Object value;

        public FilterCondition(String fieldName, FilterOperator operator, Object value) {
            this.fieldName = fieldName;
            this.operator = operator;
            this.value = value;
        }

        public String getFieldName() {
            return fieldName;
        }

        public FilterOperator getOperator() {
            return operator;
        }

        public Object getValue() {
            return value;
        }
    }


    // ================================
// FILTERING OPERATIONS
// ================================

    /**
     * Finds entities matching the specified filters.
     * <p>
     * Supports exact match filtering on entity fields. Field names in the map should match
     * entity field names (not necessarily column names). The method automatically converts
     * field names to database column names and handles type transformations.
     * </p>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * Map<String, Object> filters = new HashMap<>();
     * filters.put("name", "John");
     * filters.put("active", true);
     * filters.put("age", 25);
     *
     * List<User> users = userCRUD.findAll(filters);
     * // Generates: SELECT * FROM users WHERE name = :name AND active = :active AND age = :age
     * }</pre>
     *
     * @param filters map of field names to filter values
     * @return list of entities matching the filters
     * @throws IllegalArgumentException if filter field doesn't exist in entity
     */
    public List<E> findAll(Map<String, Object> filters) {
        if (filters == null || filters.isEmpty()) {
            return findAll();
        }

        return jdbi.withHandle(handle -> {
            String sql = buildSelectSqlWithFilters(filters);
            var query = handle.createQuery(sql);
            // Bind filter parameters
            bindFilterParameters(query, filters);
            return query.map(getRowMapper()).list();
        });
    }

    /**
     * Finds entities matching filters with pagination.
     *
     * @param filters map of field names to filter values
     * @param limit maximum number of records to return
     * @param offset number of records to skip
     * @return list of entities matching the filters within specified range
     */
    public List<E> findAll(Map<String, Object> filters, int limit, int offset) {
        if (filters == null || filters.isEmpty()) {
            return findAll(limit, offset);
        }

        return jdbi.withHandle(handle -> {
            String sql = buildSelectSqlWithFilters(filters) + " LIMIT :limit OFFSET :offset";
            var query = handle.createQuery(sql)
                    .bind("limit", limit)
                    .bind("offset", offset);
            bindFilterParameters(query, filters);

            return query.map(getRowMapper()).list();
        });
    }

    /**
     * Counts entities matching the specified filters.
     *
     * @param filters map of field names to filter values
     * @return count of entities matching the filters
     */
    public long count(Map<String, Object> filters) {
        if (filters == null || filters.isEmpty()) {
            return count();
        }

        return jdbi.withHandle(handle -> {
            String whereClause = buildWhereClause(filters);
            String sql = "SELECT COUNT(*) FROM " + tableName + whereClause;

            var query = handle.createQuery(sql);
            bindFilterParameters(query, filters);

            return query.mapTo(Long.class).one();
        });
    }

    /**
     * Checks if any entity exists matching the specified filters.
     *
     * @param filters map of field names to filter values
     * @return true if at least one matching entity exists
     */
    public boolean exists(Map<String, Object> filters) {
        if (filters == null || filters.isEmpty()) {
            return count() > 0;
        }

        return jdbi.withHandle(handle -> {
            String whereClause = buildWhereClause(filters);
            String sql = "SELECT 1 FROM " + tableName + whereClause + " LIMIT 1";

            var query = handle.createQuery(sql);
            bindFilterParameters(query, filters);

            return query.mapTo(Integer.class).findOne().isPresent();
        });
    }

    /**
     * Finds entities matching filters with sorting.
     *
     * @param filters map of field names to filter values
     * @param sortBy field name to sort by
     * @param ascending true for ascending order, false for descending
     * @return sorted list of entities matching the filters
     */
    public List<E> findAll(Map<String, Object> filters, String sortBy, boolean ascending) {
        return jdbi.withHandle(handle -> {
            String whereClause = buildWhereClause(filters);
            String orderClause = buildOrderClause(sortBy, ascending);
            String sql = "SELECT * FROM " + tableName + whereClause + orderClause;

            var query = handle.createQuery(sql);

            bindFilterParameters(query, filters);

            return query.map(getRowMapper()).list();
        });
    }

    /**
     * Builds ORDER BY clause.
     */
    private String buildOrderClause(String sortBy, boolean ascending) {
        Field field = getFieldByName(sortBy);
        String columnName = getColumnName(field);
        String direction = ascending ? "ASC" : "DESC";
        return " ORDER BY " + columnName + " " + direction;
    }


// ================================
// SQL GENERATION FOR FILTERS
// ================================

    /**
     * Builds SELECT SQL with WHERE clause based on filters.
     *
     * @param filters map of field names to filter values
     * @return complete SELECT SQL statement
     */
    private String buildSelectSqlWithFilters(Map<String, Object> filters) {
        String whereClause = buildWhereClause(filters);
        return "SELECT * FROM " + tableName + whereClause;
    }

    /**
     * Builds WHERE clause from filters.
     *
     * @param filters map of field names to filter values
     * @return WHERE clause string (e.g., " WHERE col1 = :field1 AND col2 = :field2")
     */
    private String buildWhereClause(Map<String, Object> filters) {
        if (filters.isEmpty()) {
            return "";
        }

        StringJoiner whereConditions = new StringJoiner(" AND ");

        for (Map.Entry<String, Object> entry : filters.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            if (RESERVED_KEYWORDS.contains(key)) {
                continue;
            }

            FilterCondition condition = parseFilterCondition(key, value);
            Field field = getFieldByName(condition.getFieldName());
            String columnName = getColumnName(field);

            String operator = condition.getOperator().getSqlOperator();
            String placeholder = ":" + key;

            // Handle pattern-based operators
            switch (condition.getOperator()) {
                case LIKE:
                case NOT_LIKE:
                    // Use database-specific concatenation or parameter binding
                    if (dialect == Dialect.POSTGRESQL) {
                        placeholder = ":'" + key + "'"; // Let the binding handle the pattern
                    } else {
                        placeholder = "CONCAT('%', :" + key + ", '%')";
                    }
                    break;
                case STARTS_WITH:
                    if (dialect == Dialect.POSTGRESQL) {
                        placeholder = ":'" + key + "'";
                    } else {
                        placeholder = "CONCAT(:" + key + ", '%')";
                    }
                    break;
                case ENDS_WITH:
                    if (dialect == Dialect.POSTGRESQL) {
                        placeholder = ":'" + key + "'";
                    } else {
                        placeholder = "CONCAT('%', :" + key + ")";
                    }
                    break;
                default:
                    // For other operators, use direct parameter binding
                    break;
            }

            whereConditions.add(columnName + " " + operator + " " + placeholder);
        }

        if (whereConditions.length() == 0) {
            return "";
        }

        return " WHERE " + whereConditions.toString();

    }

    /**
     * Gets field by name with validation.
     *
     * @param key the field name to look up
     * @return the Field object
     * @throws IllegalArgumentException if field doesn't exist
     */
    private Field getFieldByName(String key) {
        try {
            return validateField(entityClass.getDeclaredField(key));
        } catch (NoSuchFieldException e) {
            // If not found, check if it has an operator suffix
            for (FilterOperator op : FilterOperator.values()) {
                String suffix = "_" + op.name();
                if (key.endsWith(suffix)) {
                    String fieldName = key.substring(0, key.length() - suffix.length());
                    try {
                        return validateField(entityClass.getDeclaredField(fieldName));
                    } catch (NoSuchFieldException ex) {
                        // Continue to next operator
                    }
                }
            }
        }
        throw new IllegalArgumentException("Field '" + key + "' does not exist in entity " + entityClass.getSimpleName());
    }
    private Field validateField(Field field) {
        if (field.isAnnotationPresent(Ignore.class)) {
            throw new IllegalArgumentException(
                    "Field '" + field.getName() + "' is annotated with @Ignore and cannot be used for filtering"
            );
        }
        if (field.isAnnotationPresent(JsonColumn.class)) {
            if (field.getType() != String.class) {
                throw new IllegalArgumentException(
                        "Field '" + field.getName() + "' is annotated with @JsonColumn and must be of type String for filtering"
                );
            }
        }
        if (field.isAnnotationPresent(FileColumn.class)) {
            throw new IllegalArgumentException(
                    "Field '" + field.getName() + "' is annotated with @FileColumn and cannot be used for filtering"
            );
        }
        return field;
    }

    /**
     * Parses a filter key and value into a FilterCondition.
     * Supports format: "fieldName" (implies EQUALS) or "fieldName_OPERATOR" (e.g., "age_GT").
     *
     * @param key   the filter key (e.g., "name", "age_GT")
     * @param value the filter value
     * @return a FilterCondition object
     */
    private FilterCondition parseFilterCondition(String key, Object value) {
        // Check for explicit operator suffixes (longest first to avoid partial matches)
        List<FilterOperator> operators = Arrays.asList(FilterOperator.values());
        operators.sort((a, b) -> Integer.compare(b.name().length(), a.name().length())); // Sort by length descending

        for (FilterOperator op : operators) {
            String suffix = "_" + op.name();
            if (key.endsWith(suffix)) {
                String fieldName = key.substring(0, key.length() - suffix.length());
                // Verify this is actually a field name and not a partial match
                try {
                    entityClass.getDeclaredField(fieldName);
                    return new FilterCondition(fieldName, op, value);
                } catch (NoSuchFieldException e) {
                    // Not a valid field name, continue to next operator
                }
            }
        }

        // If no operator suffix found, assume EQUALS
        return new FilterCondition(key, FilterOperator.EQUALS, value);
    }

    /**
     * Binds filter parameters to query with type transformations.
     *
     * @param query the JDBI query
     * @param filters map of field names to filter values
     */
    private void bindFilterParameters(Query query, Map<String, Object> filters) {
        for (Map.Entry<String, Object> entry : filters.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            // Ignorar palabras reservadas
            if (RESERVED_KEYWORDS.contains(key)) {
                continue;
            }

            FilterCondition condition = parseFilterCondition(key, value);
            Field field = getFieldByName(condition.getFieldName());
            Object processedValue = processFilterValue(field, value);

            // Apply pattern formatting for LIKE operators
            switch (condition.getOperator()) {
                case LIKE:
                case NOT_LIKE:
                    processedValue = "%" + processedValue + "%";
                    break;
                case STARTS_WITH:
                    processedValue = processedValue + "%";
                    break;
                case ENDS_WITH:
                    processedValue = "%" + processedValue;
                    break;
                default:
                    // No pattern modification for other operators
                    break;
            }

            query.bind(key, processedValue); // ¡Usamos la clave original 'key' como nombre del parámetro!
        }
    }

    /**
     * Processes filter values with type transformations.
     * Similar to processFieldValue but optimized for filtering.
     *
     * @param field the field being filtered
     * @param value the filter value
     * @return transformed value suitable for SQL binding
     */
    private Object processFilterValue(Field field, Object value) {
        if (value == null) return null;

        // JSON Column filtering - serialize objects to JSON string
        if (field.isAnnotationPresent(JsonColumn.class) && !(value instanceof String)) {
            try {
                return objectMapper.writeValueAsString(value);
            } catch (Exception e) {
                throw new RuntimeException("Error serializing JSON filter value for field: " + field.getName(), e);
            }
        }

        // Enum Column transformation
        if (field.isAnnotationPresent(EnumColumn.class) && value instanceof Enum) {
            EnumColumn enumAnnotation = field.getAnnotation(EnumColumn.class);
            Enum<?> enumValue = (Enum<?>) value;
            switch (enumAnnotation.value()) {
                case STRING:
                    return enumValue.name();
                case ORDINAL:
                    return enumValue.ordinal();
                case CODE:
                    try {
                        Method getCodeMethod = enumValue.getClass().getMethod("getCode");
                        return getCodeMethod.invoke(enumValue);
                    } catch (Exception e) {
                        throw new IllegalStateException(
                                "The enum " + enumValue.getClass().getName() +
                                        " must have a getCode() method for @EnumColumn(EnumType.CODE)", e
                        );
                    }
                default:
                    return enumValue.ordinal();
            }
        }

        // For array columns, we typically want to filter by individual elements
        // This could be enhanced to support array operations in the future
        if (field.isAnnotationPresent(ArrayColumn.class) && value instanceof String) {
            // For now, treat array columns as simple string matching
            // Future enhancement: support contains, overlaps, etc.
            return value;
        }

        return value;
    }



    // ================================
    // CRUD OPERATIONS
    // ================================

    /**
     * Counts the total number of records in the table.
     *
     * @return the total record count
     */
    public long count() {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM " + tableName)
                        .mapTo(Long.class)
                        .one()
        );
    }

    /**
     * Retrieves all records from the table.
     *
     * @return list of all entities
     */
    public List<E> findAll() {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName)
                        .map(getRowMapper())
                        .list()
        );
    }

    /**
     * Retrieves a limited number of records with pagination.
     *
     * @param limit the maximum number of records to return
     * @param offset the number of records to skip
     * @return list of entities within the specified range
     */
    public List<E> findAll(int limit, int offset) {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " LIMIT :limit OFFSET :offset")
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .map(getRowMapper())
                        .list()
        );
    }

    /**
     * Finds an entity by its primary key.
     *
     * @param id the primary key value
     * @return Optional containing the entity if found, empty otherwise
     */
    public Optional<E> findById(ID id) {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " WHERE " + getIdColumnName() + " = :id")
                        .bind("id", id)
                        .map(getRowMapper())
                        .findOne()
        );
    }

    /**
     * Checks if an entity with the given ID exists.
     *
     * @param id the primary key value
     * @return true if entity exists, false otherwise
     */
    public boolean existsById(ID id) {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT 1 FROM " + tableName + " WHERE " + getIdColumnName() + " = :id LIMIT 1")
                        .bind("id", id)
                        .mapTo(Integer.class)
                        .findOne()
                        .isPresent()
        );
    }

    /**
     * Saves an entity to the database.
     * <p>
     * For auto-generated IDs, the generated key is returned. For manual IDs,
     * the entity's ID value is returned. The entity is processed automatically
     * (UUIDs generated, defaults set, timestamps updated).
     * </p>
     *
     * @param entity the entity to save
     * @return the primary key of the saved entity
     */
    public ID save(E entity) {
        return jdbi.inTransaction(handle -> {
            Update update = handle.createUpdate(buildInsertSql());
            bindInsertParameters(update, entity);

            Field idField = getIdField();
            Id idAnnotation = idField.getAnnotation(Id.class);

            if (idAnnotation.autoGenerated()) {
                return update.executeAndReturnGeneratedKeys(getIdColumnName())
                        .mapTo(getIdType())
                        .one();
            } else {
                update.execute();
                try {
                    idField.setAccessible(true);
                    return getIdType().cast(idField.get(entity));
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Error accessing ID field", e);
                }
            }
        });
    }

    /**
     * Saves multiple entities in a single transaction.
     * <p>
     * Each entity is processed individually and saved. If any save fails,
     * the entire transaction is rolled back.
     * </p>
     *
     * @param entities the list of entities to save
     */
    public void saveAll(List<E> entities) {
        if (entities == null || entities.isEmpty()) {
            return;
        }

        jdbi.inTransaction(handle -> {
            String sql = buildInsertSql();
            for (E entity : entities) {
                Update update = handle.createUpdate(sql);
                bindInsertParameters(update, entity);
                update.execute();
            }
            return null;
        });
    }

    /**
     * Updates an existing entity in the database.
     * <p>
     * The entity must have a valid ID. UpdatedDate fields are automatically
     * updated to the current timestamp.
     * </p>
     *
     * @param entity the entity to update
     * @return true if the entity was updated, false if no matching record was found
     */
    public boolean update(E entity) {
        return jdbi.inTransaction(handle -> {
            Update update = handle.createUpdate(buildUpdateSql());
            bindUpdateParameters(update, entity);
            return update.execute() > 0;
        });
    }

    /**
     * Deletes an entity by its primary key.
     *
     * @param id the primary key of the entity to delete
     * @return true if the entity was deleted, false if no matching record was found
     */
    public boolean deleteById(ID id) {
        return jdbi.inTransaction(handle ->
                handle.createUpdate("DELETE FROM " + tableName + " WHERE " + getIdColumnName() + " = :id")
                        .bind("id", id)
                        .execute() > 0
        );
    }

    /**
     * Deletes all entities from the table.
     * <p>
     * <strong>WARNING:</strong> This operation cannot be undone!
     * </p>
     *
     * @return the number of deleted records
     */
    public int deleteAll() {
        return jdbi.inTransaction(handle ->
                handle.createUpdate("DELETE FROM " + tableName)
                        .execute()
        );
    }

    // ================================
    // UTILITIES
    // ================================

    /**
     * Converts a string value to the specified field type.
     * <p>
     * Used internally for processing @Default annotation values.
     * Supports basic primitive types and their wrapper classes.
     * </p>
     *
     * @param value the string value to convert
     * @param fieldType the target field type
     * @return the converted value
     * @throws NumberFormatException if numeric conversion fails
     */
    private Object convertStringToFieldType(String value, Class<?> fieldType) {
        if (fieldType == String.class) return value;
        if (fieldType == Integer.class || fieldType == int.class) return Integer.valueOf(value);
        if (fieldType == Long.class || fieldType == long.class) return Long.valueOf(value);
        if (fieldType == Boolean.class || fieldType == boolean.class) return Boolean.valueOf(value);
        if (fieldType == Double.class || fieldType == double.class) return Double.valueOf(value);
        // Add more types as needed
        return value;
    }

    public <E> E mapRow(ResultSet rs, Class<E> entityClass) throws SQLException {
        try {
            E entity = entityClass.getDeclaredConstructor().newInstance();

            for (Field field : entityClass.getDeclaredFields()) {
                if (field.isAnnotationPresent(Ignore.class)) continue;

                field.setAccessible(true);
                String columnName = getColumnName(field); // Tu método que obtiene el nombre real de columna

                Object value = null;

                if (field.isAnnotationPresent(UUID.class)) {
                    if (dialect == Dialect.POSTGRESQL) {
                        value = rs.getObject(columnName, java.util.UUID.class);
                        if(value != null && field.getType() == String.class){
                            value = value.toString();
                        }
                    } else {
                        value = rs.getString(columnName);
                    }
                } else if (field.isAnnotationPresent(JsonColumn.class)) {
                    String json = rs.getString(columnName);
                    if (json != null) {
                        Class<?> fieldType = field.getType();
                        if (Map.class.isAssignableFrom(fieldType)) {
                            value = new ObjectMapper().readValue(json, new TypeReference<Map<String,Object>>() {});
                        } else if (JsonNode.class.isAssignableFrom(fieldType)) {
                            value = new ObjectMapper().readTree(json);
                        } else {
                            value = new ObjectMapper().readValue(json, fieldType);
                        }
                    }
                } else if (field.isAnnotationPresent(ArrayColumn.class)) {
                    ArrayColumn arrayAnno = field.getAnnotation(ArrayColumn.class);
                    String[] array = Optional.ofNullable(rs.getString(columnName)).orElse("").split(arrayAnno.separator());
                    if (List.class.isAssignableFrom(field.getType())) {
                        value = Arrays.asList(array);
                    } else if (field.getType().isArray()) {
                        value = array;
                    }
                } else if (field.isAnnotationPresent(EnumColumn.class)) {
                    EnumColumn enumAnno = field.getAnnotation(EnumColumn.class);
                    String raw = rs.getString(columnName);
                    if (raw != null) {
                        value = mapEnum(field.getType(), raw, enumAnno.value());
                    }
                } else if (field.isAnnotationPresent(FileColumn.class)) {
                    value = rs.getBytes(columnName);
                } else if (field.getType().equals(LocalDateTime.class)) {
                    Timestamp ts = rs.getTimestamp(columnName);
                    if (ts != null) value = ts.toLocalDateTime();
                } else {
                    value = rs.getObject(columnName);
                }

                // Aplicar default si null
                if (value == null && field.isAnnotationPresent(Default.class)) {
                    Default def = field.getAnnotation(Default.class);
                    value = parseDefaultValue(def.value(), field.getType());
                }

                field.set(entity, value);
            }

            return entity;

        } catch (Exception e) {
            throw new RuntimeException("Error mapping ResultSet to " + entityClass.getSimpleName(), e);
        }
    }

    private Object mapEnum(Class<?> enumClass, String raw, EnumColumn.EnumType type) {
        Object[] constants = enumClass.getEnumConstants();
        switch (type) {
            case STRING:
                for (Object c : constants) if (((Enum<?>) c).name().equals(raw)) return c;
                break;
            case ORDINAL:
                int idx = Integer.parseInt(raw);
                return constants[idx];
            case CODE:
                for (Object c : constants) {
                    try {
                        Method getCode = c.getClass().getMethod("getCode");
                        if (getCode.invoke(c).toString().equals(raw)) return c;
                    } catch (Exception ignored) {}
                }
                break;
        }
        return null;
    }

    private Object parseDefaultValue(String def, Class<?> type) {
        if (type.equals(String.class)) return def;
        if (type.equals(Boolean.class) || type.equals(boolean.class)) return Boolean.parseBoolean(def);
        if (type.equals(Integer.class) || type.equals(int.class)) return Integer.parseInt(def);
        if (type.equals(Long.class) || type.equals(long.class)) return Long.parseLong(def);
        return null;
    }

}