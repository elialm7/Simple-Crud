package com.roelias.crud;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.mapper.reflect.BeanMapper;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Update;
import org.jdbi.v3.core.transaction.TransactionIsolationLevel;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Abstract CRUD base class providing automatic SQL generation and type transformations.
 * <p>
 * This class uses annotation-driven configuration to automatically generate INSERT, UPDATE,
 * SELECT, and DELETE statements based on entity class definitions. It supports various
 * data type transformations including JSON serialization, array handling, enum storage,
 * UUID generation, and automatic timestamp management.
 * </p>
 *
 * <h3>Key Features:</h3>
 * <ul>
 *   <li>Zero-configuration CRUD operations</li>
 *   <li>Automatic SQL generation based on annotations</li>
 *   <li>Type transformations (JSON, Arrays, Enums, UUIDs)</li>
 *   <li>Automatic timestamp handling for audit fields</li>
 *   <li>Performance optimization through metadata caching</li>
 *   <li>Full transaction support with isolation levels</li>
 *   <li>Batch operations for high-performance inserts</li>
 * </ul>
 *
 * <h3>Usage Example:</h3>
 * <pre>{@code
 * @Table("users")
 * public class User {
 *     @Id(autoGenerated = true)
 *     private Long id;
 *
 *     @Column("user_name")
 *     private String name;
 *
 *     @CreatedDate
 *     private LocalDateTime createdAt;
 * }
 *
 * public class UserCRUD extends CRUD<User, Long> {
 *     public UserCRUD(Jdbi jdbi) {
 *         super(jdbi, User.class, Long.class);
 *     }
 * }
 * }</pre>
 *
 * @param <E> The entity type
 * @param <ID> The primary key type
 * @author Your Name
 * @version 1.0
 * @since 1.0
 */
public abstract class CRUD<E, ID> {

    protected final Jdbi jdbi;
    protected final String tableName;
    private final Class<E> entityClass;
    private final Class<ID> idType;
    private static final ObjectMapper objectMapper = new ObjectMapper();

    // ================================
    // ANNOTATIONS
    // ================================

    /**
     * Marks a class as a database table entity.
     * <p>
     * This annotation is required on all entity classes to specify the table name
     * and optionally the schema name.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Table {
        /**
         * The table name in the database.
         * @return table name
         */
        String value();

        /**
         * The schema name (optional). If provided, queries will use schema.table format.
         * @return schema name, empty string if not specified
         */
        String schema() default "";
    }

    /**
     * Maps a field to a specific database column name.
     * <p>
     * If not specified, the field name will be used as the column name.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Column {
        /**
         * The column name in the database.
         * @return column name, or empty string to use field name
         */
        String value() default "";
    }

    /**
     * Marks a field as the primary key.
     * <p>
     * Only one field per entity should have this annotation.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Id {
        /**
         * Whether the ID is auto-generated by the database.
         * <p>
         * If true, the field will be excluded from INSERT statements and the generated
         * key will be returned. If false, you must provide the ID value before saving.
         * </p>
         *
         * @return true if auto-generated, false if manually provided
         */
        boolean autoGenerated() default true;
    }

    /**
     * Marks a String field for automatic UUID generation.
     * <p>
     * A random UUID will be generated and assigned to the field if it's null
     * during save operations.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UUID {
        /**
         * Whether to automatically generate UUIDs for null fields.
         * @return true to auto-generate, false to leave null fields as-is
         */
        boolean autoGenerate() default true;
    }

    /**
     * Marks a field for JSON serialization/deserialization.
     * <p>
     * The field value will be automatically serialized to JSON string when saving
     * and can be deserialized when loading. Supports Objects, Maps, Lists, and JsonNode.
     * </p>
     *
     * <h4>Supported Types:</h4>
     * <ul>
     *   <li>Custom Objects - Serialized using Jackson ObjectMapper</li>
     *   <li>Map&lt;String,Object&gt; - For dynamic key-value data</li>
     *   <li>JsonNode - For raw JSON manipulation</li>
     *   <li>Lists and Arrays of objects</li>
     * </ul>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface JsonColumn {
    }

    /**
     * Marks a field for array serialization using a separator.
     * <p>
     * List&lt;String&gt; and String[] fields will be joined into a single string
     * using the specified separator for database storage.
     * </p>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * @ArrayColumn(separator = ",")
     * private List<String> tags; // Stored as "tag1,tag2,tag3"
     *
     * @ArrayColumn(separator = "|")
     * private String[] categories; // Stored as "cat1|cat2|cat3"
     * }</pre>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ArrayColumn {
        /**
         * The separator used to join array elements.
         * @return separator string, defaults to comma
         */
        String separator() default ",";
    }

    /**
     * Marks a byte[] field as file storage.
     * <p>
     * This is a marker annotation for documentation purposes. The field will be
     * stored as BLOB/BYTEA in the database.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface FileColumn {
    }

    /**
     * Marks a field to be ignored during database operations.
     * <p>
     * Fields with this annotation will not be included in INSERT or UPDATE statements.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Ignore {
    }

    /**
     * Marks a LocalDateTime field for automatic creation timestamp.
     * <p>
     * The field will be automatically set to the current timestamp when the entity
     * is saved for the first time. This field is excluded from UPDATE statements.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface CreatedDate {
    }

    /**
     * Marks a LocalDateTime field for automatic update timestamp.
     * <p>
     * The field will be automatically set to the current timestamp whenever the
     * entity is saved or updated.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UpdatedDate {
    }

    /**
     * Specifies a default value for a field.
     * <p>
     * If the field is null during save operations, it will be set to the specified
     * default value. The value is automatically converted to the field's type.
     * </p>
     *
     * <h4>Supported Types:</h4>
     * <ul>
     *   <li>String</li>
     *   <li>Integer/int</li>
     *   <li>Long/long</li>
     *   <li>Boolean/boolean</li>
     *   <li>Double/double</li>
     * </ul>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Default {
        /**
         * The default value as a string (will be converted to field type).
         * @return default value
         */
        String value();
    }

    /**
     * Configures enum field storage strategy.
     * <p>
     * Determines how enum values are stored in the database.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface EnumColumn {
        /**
         * The enum storage strategy.
         * @return the enum type strategy
         */
        EnumType value() default EnumType.STRING;

        /**
         * Enum storage strategies.
         */
        enum EnumType {
            /**
             * Store enum as string using name() method (e.g., "ACTIVE", "INACTIVE").
             * <p>
             * <strong>Pros:</strong> Human-readable, refactor-safe<br>
             * <strong>Cons:</strong> Larger storage size
             * </p>
             */
            STRING,

            /**
             * Store enum as integer using ordinal() method (e.g., 0, 1, 2).
             * <p>
             * <strong>Pros:</strong> Compact storage<br>
             * <strong>Cons:</strong> Fragile to enum reordering
             * </p>
             */
            ORDINAL,

            /**
             * Store enum using custom getCode() method.
             * <p>
             * The enum must implement a getCode() method that returns a String or primitive.
             * <strong>Example:</strong>
             * <pre>{@code
             * public enum Status {
             *     ACTIVE("ACT"), INACTIVE("INA");
             *     private final String code;
             *     Status(String code) { this.code = code; }
             *     public String getCode() { return code; }
             * }
             * }</pre>
             * </p>
             */
            CODE
        }
    }

    // Performance optimization caches
    private static final Map<Class<?>, String> tableNameCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field[]> insertableFieldsCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field[]> updatableFieldsCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field> idFieldCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, String> insertSqlCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, String> updateSqlCache = new ConcurrentHashMap<>();
    /**
     * Creates a new CRUD instance for the specified entity.
     * <p>
     * The table name is automatically extracted from the @Table annotation on the entity class.
     * </p>
     *
     * @param jdbi the JDBI instance for database operations
     * @param entityClass the entity class (must be annotated with @Table)
     * @param idType the primary key type
     * @throws IllegalArgumentException if the entity class is not annotated with @Table
     */
    public CRUD(Jdbi jdbi, Class<E> entityClass, Class<ID> idType) {
        this.jdbi = jdbi;
        this.entityClass = entityClass;
        this.idType = idType;
        this.tableName = extractTableName();
    }

    /**
     * Extracts the table name from the @Table annotation.
     *
     * @return the full table name (schema.table or just table)
     * @throws IllegalArgumentException if @Table annotation is missing
     */
    private String extractTableName() {
        return tableNameCache.computeIfAbsent(entityClass, clazz -> {
            Table tableAnnotation = clazz.getAnnotation(Table.class);
            if (tableAnnotation == null) {
                throw new IllegalArgumentException(
                        "Entity " + clazz.getName() + " must be annotated with @Table"
                );
            }

            String schema = tableAnnotation.schema();
            String table = tableAnnotation.value();
            return schema.isEmpty() ? table : schema + "." + table;
        });
    }

    /**
     * Gets the database column name for the ID field.
     *
     * @return the ID column name
     */
    protected String getIdColumnName() {
        Field idField = getIdField();
        Column column = idField.getAnnotation(Column.class);
        return column != null && !column.value().isEmpty() ? column.value() : idField.getName();
    }

    /**
     * Gets the ID type class.
     *
     * @return the ID type class
     */
    protected Class<ID> getIdType() {
        return idType;
    }

    /**
     * Creates a RowMapper for automatic result set mapping.
     * <p>
     * Override this method to provide custom mapping logic if needed.
     * </p>
     *
     * @return the row mapper for this entity type
     */
    protected org.jdbi.v3.core.mapper.RowMapper<E> getRowMapper() {
        return BeanMapper.of(entityClass);
    }



    // ================================
    // AUTOMATIC SQL GENERATION
    // ================================

    /**
     * Builds the INSERT SQL statement for this entity.
     * <p>
     * The SQL is generated based on entity annotations and cached for performance.
     * Only non-ignored fields and non-auto-generated ID fields are included.
     * </p>
     *
     * @return the INSERT SQL statement
     */
    protected String buildInsertSql() {
        return insertSqlCache.computeIfAbsent(entityClass, clazz -> {
            Field[] fields = getInsertableFields();

            StringJoiner columns = new StringJoiner(", ");
            StringJoiner placeholders = new StringJoiner(", ");

            for (Field field : fields) {
                String columnName = getColumnName(field);
                columns.add(columnName);
                placeholders.add(":" + field.getName());
            }

            return "INSERT INTO " + tableName + " (" + columns + ") VALUES (" + placeholders + ")";
        });
    }

    /**
     * Builds the UPDATE SQL statement for this entity.
     * <p>
     * The SQL is generated based on entity annotations and cached for performance.
     * CreatedDate fields are excluded from updates, but UpdatedDate fields are included.
     * </p>
     *
     * @return the UPDATE SQL statement
     */
    protected String buildUpdateSql() {
        return updateSqlCache.computeIfAbsent(entityClass, clazz -> {
            Field[] fields = getUpdatableFields();
            Field idField = getIdField();

            StringJoiner setClauses = new StringJoiner(", ");

            for (Field field : fields) {
                if (!field.equals(idField) && !field.isAnnotationPresent(CreatedDate.class)) {
                    String columnName = getColumnName(field);
                    setClauses.add(columnName + " = :" + field.getName());
                }
            }

            return "UPDATE " + tableName + " SET " + setClauses + " WHERE " + getIdColumnName() + " = :" + idField.getName();
        });
    }

    // ================================
    // AUTOMATIC PARAMETER BINDING WITH TRANSFORMATIONS
    // ================================

    /**
     * Binds parameters for INSERT operations with automatic transformations.
     * <p>
     * Processes the entity by generating UUIDs, setting defaults, and timestamps
     * before binding parameters to the statement.
     * </p>
     *
     * @param update the JDBI Update statement
     * @param entity the entity to bind
     */
    protected void bindInsertParameters(Update update, E entity) {
        processEntityForInsert(entity);
        bindParameters(update, entity, getInsertableFields());
    }

    /**
     * Binds parameters for UPDATE operations with automatic transformations.
     * <p>
     * Processes the entity by updating timestamps before binding parameters.
     * </p>
     *
     * @param update the JDBI Update statement
     * @param entity the entity to bind
     */
    protected void bindUpdateParameters(Update update, E entity) {
        processEntityForUpdate(entity);
        bindParameters(update, entity, getAllFields());
    }

    /**
     * Binds parameters for BATCH operations with automatic transformations.
     *
     * @param batch the JDBI PreparedBatch statement
     * @param entity the entity to bind
     */
    protected void bindBatchParameters(PreparedBatch batch, E entity) {
        processEntityForInsert(entity);
        bindParameters(batch, entity, getInsertableFields());
    }

    /**
     * Binds field values to statement parameters with type transformations.
     *
     * @param statement the JDBI statement (Update or PreparedBatch)
     * @param entity the entity containing values
     * @param fields the fields to bind
     */
    private void bindParameters(Object statement, E entity, Field[] fields) {
        for (Field field : fields) {
            try {
                field.setAccessible(true);
                Object value = field.get(entity);
                Object processedValue = processFieldValue(field, value);

                if (statement instanceof Update) {
                    ((Update) statement).bind(field.getName(), processedValue);
                } else if (statement instanceof PreparedBatch) {
                    ((PreparedBatch) statement).bind(field.getName(), processedValue);
                }
            } catch (IllegalAccessException e) {
                throw new RuntimeException("Error accessing field: " + field.getName(), e);
            }
        }
    }

    // ================================
    // AUTOMATIC FIELD PROCESSING
    // ================================

    /**
     * Processes entity fields before INSERT operations.
     * <p>
     * Performs the following operations in order:
     * <ol>
     *   <li>Generate UUIDs for @UUID annotated fields</li>
     *   <li>Set default values for @Default annotated fields</li>
     *   <li>Set timestamps for @CreatedDate and @UpdatedDate fields</li>
     * </ol>
     * </p>
     *
     * @param entity the entity to process
     */
    private void processEntityForInsert(E entity) {
        generateUUIDs(entity);
        setDefaultValues(entity);
        setTimestamp(entity, CreatedDate.class);
        setTimestamp(entity, UpdatedDate.class);
    }

    /**
     * Processes entity fields before UPDATE operations.
     * <p>
     * Only updates @UpdatedDate fields with the current timestamp.
     * </p>
     *
     * @param entity the entity to process
     */
    private void processEntityForUpdate(E entity) {
        setTimestamp(entity, UpdatedDate.class);
    }

    /**
     * Generates UUIDs for @UUID annotated fields that are null.
     *
     * @param entity the entity to process
     */
    private void generateUUIDs(E entity) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(UUID.class))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        Object currentValue = field.get(entity);

                        if (currentValue == null) {
                            UUID uuidAnnotation = field.getAnnotation(UUID.class);
                            if (uuidAnnotation.autoGenerate() && field.getType() == String.class) {
                                field.set(entity, java.util.UUID.randomUUID().toString());
                            }
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error generating UUID for field: " + field.getName(), e);
                    }
                });
    }

    /**
     * Sets default values for @Default annotated fields that are null.
     *
     * @param entity the entity to process
     */
    private void setDefaultValues(E entity) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(Default.class))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        Object currentValue = field.get(entity);

                        if (currentValue == null) {
                            Default defaultAnnotation = field.getAnnotation(Default.class);
                            Object defaultValue = convertStringToFieldType(defaultAnnotation.value(), field.getType());
                            field.set(entity, defaultValue);
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error setting default value for field: " + field.getName(), e);
                    }
                });
    }

    /**
     * Sets timestamp fields with the current LocalDateTime.
     *
     * @param entity the entity to process
     * @param annotationClass the timestamp annotation class (CreatedDate or UpdatedDate)
     */
    private void setTimestamp(E entity, Class<? extends java.lang.annotation.Annotation> annotationClass) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(annotationClass))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        if (field.getType() == LocalDateTime.class) {
                            field.set(entity, LocalDateTime.now());
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error setting timestamp for field: " + field.getName(), e);
                    }
                });
    }

    // ================================
    // TYPE TRANSFORMATIONS
    // ================================

    /**
     * Processes field values with type-specific transformations.
     * <p>
     * Handles the following transformations:
     * <ul>
     *   <li>@JsonColumn: Serializes objects to JSON strings</li>
     *   <li>@ArrayColumn: Joins arrays/lists with specified separator</li>
     *   <li>@EnumColumn: Converts enums based on storage strategy</li>
     * </ul>
     * </p>
     *
     * @param field the field being processed
     * @param value the field value
     * @return the transformed value for database storage
     */
    private Object processFieldValue(Field field, Object value) {
        if (value == null) return null;

        // JSON Column serialization
        if (field.isAnnotationPresent(JsonColumn.class) && !(value instanceof String)) {
            try {
                return objectMapper.writeValueAsString(value);
            } catch (Exception e) {
                throw new RuntimeException("Error serializing JSON field: " + field.getName(), e);
            }
        }

        // Array Column joining
        if (field.isAnnotationPresent(ArrayColumn.class)) {
            ArrayColumn arrayAnnotation = field.getAnnotation(ArrayColumn.class);
            if (value instanceof List) {
                return String.join(arrayAnnotation.separator(),
                        ((List<?>) value).stream().map(Object::toString).toArray(String[]::new));
            } else if (value instanceof String[]) {
                return String.join(arrayAnnotation.separator(), (String[]) value);
            }
        }

        // Enum Column transformation
        if (field.isAnnotationPresent(EnumColumn.class) && value instanceof Enum) {
            EnumColumn enumAnnotation = field.getAnnotation(EnumColumn.class);
            Enum<?> enumValue = (Enum<?>) value;
            switch (enumAnnotation.value()) {
                case STRING:
                    return enumValue.name();
                case ORDINAL:
                    return enumValue.ordinal();
                case CODE:
                    try {
                        Method getCodeMethod = enumValue.getClass().getMethod("getCode");
                        return getCodeMethod.invoke(enumValue);
                    } catch (Exception e) {
                        throw new IllegalStateException(
                                "The enum " + enumValue.getClass().getName() +
                                        " must have a getCode() method for @EnumColumn(EnumType.CODE)", e
                        );
                    }
                default:
                    return enumValue.ordinal();
            }
        }

        return value;
    }

    // ================================
    // REFLECTION UTILITIES WITH CACHING
    // ================================

    /**
     * Gets fields that should be included in INSERT statements.
     * <p>
     * Excludes @Ignore fields and auto-generated @Id fields.
     * Results are cached for performance.
     * </p>
     *
     * @return array of insertable fields
     */
    private Field[] getInsertableFields() {
        return insertableFieldsCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> !field.isAnnotationPresent(Ignore.class))
                        .filter(field -> {
                            Id idAnnotation = field.getAnnotation(Id.class);
                            return idAnnotation == null || !idAnnotation.autoGenerated();
                        })
                        .toArray(Field[]::new)
        );
    }

    /**
     * Gets fields that should be included in UPDATE statements.
     * <p>
     * Excludes only @Ignore fields. Results are cached for performance.
     * </p>
     *
     * @return array of updatable fields
     */
    private Field[] getUpdatableFields() {
        return updatableFieldsCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> !field.isAnnotationPresent(Ignore.class))
                        .toArray(Field[]::new)
        );
    }

    /**
     * Gets all declared fields of the entity class.
     *
     * @return array of all fields
     */
    private Field[] getAllFields() {
        return entityClass.getDeclaredFields();
    }

    /**
     * Gets the @Id annotated field from the entity class.
     * <p>
     * Results are cached for performance.
     * </p>
     *
     * @return the ID field
     * @throws RuntimeException if no @Id field is found
     */
    private Field getIdField() {
        return idFieldCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> field.isAnnotationPresent(Id.class))
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("No @Id field found in " + clazz.getName()))
        );
    }

    /**
     * Gets the database column name for a field.
     * <p>
     * Uses @Column annotation value if present, otherwise uses field name.
     * </p>
     *
     * @param field the field to get column name for
     * @return the column name
     */
    private String getColumnName(Field field) {
        Column column = field.getAnnotation(Column.class);
        return column != null && !column.value().isEmpty() ? column.value() : field.getName();
    }

    // ================================
    // CRUD OPERATIONS
    // ================================

    /**
     * Counts the total number of records in the table.
     *
     * @return the total record count
     */
    public long count() {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM " + tableName)
                        .mapTo(Long.class)
                        .one()
        );
    }

    /**
     * Retrieves all records from the table.
     *
     * @return list of all entities
     */
    public List<E> findAll() {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName)
                        .map(getRowMapper())
                        .list()
        );
    }

    /**
     * Retrieves a limited number of records with pagination.
     *
     * @param limit the maximum number of records to return
     * @param offset the number of records to skip
     * @return list of entities within the specified range
     */
    public List<E> findAll(int limit, int offset) {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " LIMIT :limit OFFSET :offset")
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .map(getRowMapper())
                        .list()
        );
    }

    /**
     * Finds an entity by its primary key.
     *
     * @param id the primary key value
     * @return Optional containing the entity if found, empty otherwise
     */
    public Optional<E> findById(ID id) {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " WHERE " + getIdColumnName() + " = :id")
                        .bind("id", id)
                        .map(getRowMapper())
                        .findOne()
        );
    }

    /**
     * Checks if an entity with the given ID exists.
     *
     * @param id the primary key value
     * @return true if entity exists, false otherwise
     */
    public boolean existsById(ID id) {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT 1 FROM " + tableName + " WHERE " + getIdColumnName() + " = :id LIMIT 1")
                        .bind("id", id)
                        .mapTo(Integer.class)
                        .findOne()
                        .isPresent()
        );
    }

    /**
     * Saves an entity to the database.
     * <p>
     * For auto-generated IDs, the generated key is returned. For manual IDs,
     * the entity's ID value is returned. The entity is processed automatically
     * (UUIDs generated, defaults set, timestamps updated).
     * </p>
     *
     * @param entity the entity to save
     * @return the primary key of the saved entity
     */
    public ID save(E entity) {
        return jdbi.inTransaction(handle -> {
            Update update = handle.createUpdate(buildInsertSql());
            bindInsertParameters(update, entity);

            Field idField = getIdField();
            Id idAnnotation = idField.getAnnotation(Id.class);

            if (idAnnotation.autoGenerated()) {
                return update.executeAndReturnGeneratedKeys(getIdColumnName())
                        .mapTo(getIdType())
                        .one();
            } else {
                update.execute();
                try {
                    idField.setAccessible(true);
                    return getIdType().cast(idField.get(entity));
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Error accessing ID field", e);
                }
            }
        });
    }

    /**
     * Saves multiple entities in a single transaction.
     * <p>
     * Each entity is processed individually and saved. If any save fails,
     * the entire transaction is rolled back.
     * </p>
     *
     * @param entities the list of entities to save
     */
    public void saveAll(List<E> entities) {
        if (entities == null || entities.isEmpty()) {
            return;
        }

        jdbi.inTransaction(handle -> {
            String sql = buildInsertSql();
            for (E entity : entities) {
                Update update = handle.createUpdate(sql);
                bindInsertParameters(update, entity);
                update.execute();
            }
            return null;
        });
    }

    /**
     * Updates an existing entity in the database.
     * <p>
     * The entity must have a valid ID. UpdatedDate fields are automatically
     * updated to the current timestamp.
     * </p>
     *
     * @param entity the entity to update
     * @return true if the entity was updated, false if no matching record was found
     */
    public boolean update(E entity) {
        return jdbi.inTransaction(handle -> {
            Update update = handle.createUpdate(buildUpdateSql());
            bindUpdateParameters(update, entity);
            return update.execute() > 0;
        });
    }

    /**
     * Deletes an entity by its primary key.
     *
     * @param id the primary key of the entity to delete
     * @return true if the entity was deleted, false if no matching record was found
     */
    public boolean deleteById(ID id) {
        return jdbi.inTransaction(handle ->
                handle.createUpdate("DELETE FROM " + tableName + " WHERE " + getIdColumnName() + " = :id")
                        .bind("id", id)
                        .execute() > 0
        );
    }

    /**
     * Deletes all entities from the table.
     * <p>
     * <strong>WARNING:</strong> This operation cannot be undone!
     * </p>
     *
     * @return the number of deleted records
     */
    public int deleteAll() {
        return jdbi.inTransaction(handle ->
                handle.createUpdate("DELETE FROM " + tableName)
                        .execute()
        );
    }

    /**
     * Saves an entity within a transaction with specified isolation level.
     * <p>
     * Useful when you need specific transaction isolation guarantees.
     * </p>
     *
     * @param entity the entity to save
     * @param isolation the transaction isolation level
     * @return the primary key of the saved entity
     */
    public ID saveInTransaction(E entity, TransactionIsolationLevel isolation) {
        return jdbi.inTransaction(isolation, handle -> {
            Update update = handle.createUpdate(buildInsertSql());
            bindInsertParameters(update, entity);
            return update.executeAndReturnGeneratedKeys(getIdColumnName())
                    .mapTo(getIdType())
                    .one();
        });
    }

    /**
     * Saves multiple entities using batch processing for optimal performance.
     * <p>
     * This method is significantly faster than saveAll() for large datasets
     * as it uses JDBI's batch processing capabilities.
     * </p>
     *
     * @param entities the list of entities to save
     */
    public void saveAllBatch(List<E> entities) {
        if (entities == null || entities.isEmpty()) {
            return;
        }

        jdbi.inTransaction(handle -> {
            String sql = buildInsertSql();
            var batch = handle.prepareBatch(sql);

            for (E entity : entities) {
                bindBatchParameters(batch, entity);
                batch.add();
            }

            batch.execute();
            return null;
        });
    }

    /**
     * Executes custom logic within a transaction.
     * <p>
     * Provides access to the JDBI Handle for custom database operations
     * while maintaining transaction boundaries.
     * </p>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * String result = crud.executeInTransaction(handle -> {
     *     // Custom SQL operations
     *     handle.createUpdate("UPDATE users SET last_login = NOW()").execute();
     *     return "Login updated";
     * });
     * }</pre>
     *
     * @param <T> the return type of the callback
     * @param callback the transaction callback
     * @return the result returned by the callback
     */
    public <T> T executeInTransaction(TransactionCallback<T> callback) {
        return jdbi.inTransaction(callback::execute);
    }

    /**
     * Functional interface for transaction callbacks.
     *
     * @param <T> the return type
     */
    @FunctionalInterface
    public interface TransactionCallback<T> {
        /**
         * Executes custom logic within a transaction.
         *
         * @param handle the JDBI handle
         * @return the result of the operation
         */
        T execute(org.jdbi.v3.core.Handle handle);
    }

    // ================================
    // UTILITIES
    // ================================

    /**
     * Converts a string value to the specified field type.
     * <p>
     * Used internally for processing @Default annotation values.
     * Supports basic primitive types and their wrapper classes.
     * </p>
     *
     * @param value the string value to convert
     * @param fieldType the target field type
     * @return the converted value
     * @throws NumberFormatException if numeric conversion fails
     */
    private Object convertStringToFieldType(String value, Class<?> fieldType) {
        if (fieldType == String.class) return value;
        if (fieldType == Integer.class || fieldType == int.class) return Integer.valueOf(value);
        if (fieldType == Long.class || fieldType == long.class) return Long.valueOf(value);
        if (fieldType == Boolean.class || fieldType == boolean.class) return Boolean.valueOf(value);
        if (fieldType == Double.class || fieldType == double.class) return Double.valueOf(value);
        // Add more types as needed
        return value;
    }
}