package com.roelias.crud;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Update;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public abstract class CRUD<E, ID> {

    protected final Jdbi jdbi;
    protected final String tableName;
    private final Class<E> entityClass;
    private final Class<ID> idType;
    private Dialect dialect;
    private boolean userJdbiProvider = false;
    private JdbiProvider provider = null;
    private static final ObjectMapper objectMapper = new ObjectMapper();

    // ================================
    // ANNOTATIONS
    // ================================

    public enum Dialect{
        MYSQL,
        POSTGRESQL
    }

    /**
     * Marks a class as a database table entity.
     * <p>
     * This annotation is required on all entity classes to specify the table name
     * and optionally the schema name.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Table {
        /**
         * The table name in the database.
         * @return table name
         */
        String value();

        /**
         * The schema name (optional). If provided, queries will use schema.table format.
         * @return schema name, empty string if not specified
         */
        String schema() default "";

        Dialect dialect() default Dialect.MYSQL;
    }

    /**
     * Maps a field to a specific database column name.
     * <p>
     * If not specified, the field name will be used as the column name.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Column {
        /**
         * The column name in the database.
         * @return column name, or empty string to use field name
         */
        String value() default "";
    }

    /**
     * Marks a field as the primary key.
     * <p>
     * Only one field per entity should have this annotation.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Id {
        /**
         * Whether the ID is auto-generated by the database.
         * <p>
         * If true, the field will be excluded from INSERT statements and the generated
         * key will be returned. If false, you must provide the ID value before saving.
         * </p>
         *
         * @return true if auto-generated, false if manually provided
         */
        boolean autoGenerated() default true;
    }

    /**
     * Marks a String field for automatic UUID generation.
     * <p>
     * A random UUID will be generated and assigned to the field if it's null
     * during save operations.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UUID {
        /**
         * Whether to automatically generate UUIDs for null fields.
         * @return true to auto-generate, false to leave null fields as-is
         */
        boolean autoGenerate() default true;
    }

    /**
     * Marks a field for JSON serialization/deserialization.
     * <p>
     * The field value will be automatically serialized to JSON string when saving
     * and can be deserialized when loading. Supports Objects, Maps, Lists, and JsonNode.
     * </p>
     *
     * <h4>Supported Types:</h4>
     * <ul>
     *   <li>Custom Objects - Serialized using Jackson ObjectMapper</li>
     *   <li>Map&lt;String,Object&gt; - For dynamic key-value data</li>
     *   <li>JsonNode - For raw JSON manipulation</li>
     *   <li>Lists and Arrays of objects</li>
     * </ul>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface JsonColumn {
    }

    /**
     * Marks a field for array serialization using a separator.
     * <p>
     * List&lt;String&gt; and String[] fields will be joined into a single string
     * using the specified separator for database storage.
     * </p>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * @ArrayColumn(separator = ",")
     * private List<String> tags; // Stored as "tag1,tag2,tag3"
     *
     * @ArrayColumn(separator = "|")
     * private String[] categories; // Stored as "cat1|cat2|cat3"
     * }</pre>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ArrayColumn {
        /**
         * The separator used to join array elements.
         * @return separator string, defaults to comma
         */
        String separator() default ",";
    }

    /**
     * Marks a byte[] field as file storage.
     * <p>
     * This is a marker annotation for documentation purposes. The field will be
     * stored as BLOB/BYTEA in the database.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface FileColumn {
    }

    /**
     * Marks a field to be ignored during database operations.
     * <p>
     * Fields with this annotation will not be included in INSERT or UPDATE statements.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Ignore {
    }

    /**
     * Marks a LocalDateTime field for automatic creation timestamp.
     * <p>
     * The field will be automatically set to the current timestamp when the entity
     * is saved for the first time. This field is excluded from UPDATE statements.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface CreatedDate {
    }

    /**
     * Marks a LocalDateTime field for automatic update timestamp.
     * <p>
     * The field will be automatically set to the current timestamp whenever the
     * entity is saved or updated.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UpdatedDate {
    }

    /**
     * Specifies a default value for a field.
     * <p>
     * If the field is null during save operations, it will be set to the specified
     * default value. The value is automatically converted to the field's type.
     * </p>
     *
     * <h4>Supported Types:</h4>
     * <ul>
     *   <li>String</li>
     *   <li>Integer/int</li>
     *   <li>Long/long</li>
     *   <li>Boolean/boolean</li>
     *   <li>Double/double</li>
     * </ul>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Default {
        /**
         * The default value as a string (will be converted to field type).
         * @return default value
         */
        String value();
    }

    /**
     * Configures enum field storage strategy.
     * <p>
     * Determines how enum values are stored in the database.
     * </p>
     *
     * @since 1.0
     */
    @Target(ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface EnumColumn {
        /**
         * The enum storage strategy.
         * @return the enum type strategy
         */
        EnumType value() default EnumType.STRING;

        /**
         * Enum storage strategies.
         */
        enum EnumType {
            /**
             * Store enum as string using name() method (e.g., "ACTIVE", "INACTIVE").
             * <p>
             * <strong>Pros:</strong> Human-readable, refactor-safe<br>
             * <strong>Cons:</strong> Larger storage size
             * </p>
             */
            STRING,

            /**
             * Store enum as integer using ordinal() method (e.g., 0, 1, 2).
             * <p>
             * <strong>Pros:</strong> Compact storage<br>
             * <strong>Cons:</strong> Fragile to enum reordering
             * </p>
             */
            ORDINAL,

            /**
             * Store enum using custom getCode() method.
             * <p>
             * The enum must implement a getCode() method that returns a String or primitive.
             * <strong>Example:</strong>
             * <pre>{@code
             * public enum Status {
             *     ACTIVE("ACT"), INACTIVE("INA");
             *     private final String code;
             *     Status(String code) { this.code = code; }
             *     public String getCode() { return code; }
             * }
             * }</pre>
             * </p>
             */
            CODE
        }
    }

    // Performance optimization caches
    private static final Map<Class<?>, String> tableNameCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field[]> insertableFieldsCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field[]> updatableFieldsCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Field> idFieldCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, String> insertSqlCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, String> updateSqlCache = new ConcurrentHashMap<>();
    /**
     * Creates a new CRUD instance for the specified entity.
     * <p>
     * The table name is automatically extracted from the @Table annotation on the entity class.
     * </p>
     *
     * @param jdbi the JDBI instance for database operations
     * @param entityClass the entity class (must be annotated with @Table)
     * @param idType the primary key type
     * @throws IllegalArgumentException if the entity class is not annotated with @Table
     */
    public CRUD(Jdbi jdbi, Class<E> entityClass, Class<ID> idType) {
        this.jdbi = jdbi;
        this.entityClass = entityClass;
        this.idType = idType;
        this.tableName = extractTableName();
    }

    /**
     * Creates a new CRUD instance without a JDBI instance. Instead sets a flag to use a provider later.
     * @param entityClass the entity class (must be annotated with @Table)
     * @param idType the primary key type
     * @throws IllegalArgumentException if the entity class is not annotated with @Table
     */
    public CRUD(Class<E> entityClass, Class<ID> idType) {
        this.jdbi = null;
        this.entityClass = entityClass;
        this.idType = idType;
        this.tableName = extractTableName();
        this.userJdbiProvider = true;
    }

    /**
     * Sets a JDBI provider to be used for database operations.
     * @param jdbiProvider the JDBI provider
     */
    protected void useProvider(JdbiProvider jdbiProvider) {
        this.provider = jdbiProvider;
    }

    /**
     * Gets the configured JDBI instance, either from the provider or the direct instance.
     * @return the JDBI instance
     * @Throws IllegalStateException if no JDBI instance or provider is set
     */

    protected Jdbi getConfiguredJdbi(){
        if(userJdbiProvider){
            if(provider == null){
                throw new IllegalStateException("JdbiProvider not set. Use useProvider() to set it before performing operations.");
            }
            return provider.getJdbi();
        } else {
            return jdbi;
        }
    }
    /**
     * Extracts the table name from the @Table annotation.
     *
     * @return the full table name (schema.table or just table)
     * @throws IllegalArgumentException if @Table annotation is missing
     */
    private String extractTableName() {
        return tableNameCache.computeIfAbsent(entityClass, clazz -> {
            Table tableAnnotation = clazz.getAnnotation(Table.class);
            if (tableAnnotation == null) {
                throw new IllegalArgumentException(
                        "Entity " + clazz.getName() + " must be annotated with @Table"
                );
            }

            String schema = tableAnnotation.schema();
            String table = tableAnnotation.value();
            dialect = tableAnnotation.dialect();
            return schema.isEmpty() ? table : schema + "." + table;
        });

    }

    /**
     * Gets the database column name for the ID field.
     *
     * @return the ID column name
     */
    protected String getIdColumnName() {
        Field idField = getIdField();
        Column column = idField.getAnnotation(Column.class);
        return column != null && !column.value().isEmpty() ? column.value() : idField.getName();
    }

    /**
     *  Gets the table name for the entity.
     * @return  the table name
     */
    protected  String getTableName(){
        return tableName;
    }
    /**
     * Gets the ID type class.
     *
     * @return the ID type class
     */
    protected Class<ID> getIdType() {
        return idType;
    }

    /**
     * Creates a RowMapper for automatic result set mapping.
     * <p>
     * Override this method to provide custom mapping logic if needed.
     * </p>
     *
     * @return the row mapper for this entity type
     */
    protected org.jdbi.v3.core.mapper.RowMapper<E> getRowMapper() {
         return (rs, ctx) -> mapRow(rs, entityClass);
    }


    /**
     * Creates a RowMapper for any class that uses CRUD field annotations.
     * <p>
     * Reuses the same mapping logic for DTOs, custom result classes, or joined queries.
     * No @Table annotation required - only field-level annotations are used.
     * </p>
     *
     * <h4>Example Usage:</h4>
     * <pre>{@code
     * // DTO class - NO necesita @Table!
     * public class UsuarioDetalles {
     *     @Column("user_name")
     *     private String nombre;
     *
     *     @Column("role_name")
     *     private String rol;
     *
     *     @JsonColumn
     *     private Map<String, Object> metadata;
     * }
     *
     * // En tu repositorio
     * public List<UsuarioDetalles> findUserDetails() {
     *     return jdbi.withHandle(handle ->
     *         handle.createQuery("SELECT u.name as user_name, r.name as role_name, u.metadata FROM users u JOIN roles r ON u.role_id = r.id")
     *         .map(getCustomRowMapper(UsuarioDetalles.class)) // âœ… Funciona sin @Table
     *         .list()
     *     );
     * }
     * }</pre>
     *
     * @param <T> the target class type
     * @param targetClass the class to map results to (must have a no-arg constructor)
     * @return a RowMapper instance for the target class
     */
    public <T> org.jdbi.v3.core.mapper.RowMapper<T> getCustomRowMapper(Class<T> targetClass) {
        return (rs, ctx) -> mapRow(rs, targetClass);
    }


    /**
     * Generates a DDL CREATE TABLE template based on entity annotations.
     * <p>
     * This method analyzes the entity class and its field annotations to generate
     * an appropriate CREATE TABLE statement for the specified database dialect.
     * The template serves as a reference for supported data types and can be used
     * as a starting point for actual table creation.
     * </p>
     *
     * <h4>Supported Features:</h4>
     * <ul>
     *   <li>Primary keys with auto-increment/sequences</li>
     *   <li>JSON columns for complex data structures</li>
     *   <li>Array columns with separators (stored as TEXT)</li>
     *   <li>UUID fields (native UUID in PostgreSQL, VARCHAR(36) in MySQL)</li>
     *   <li>File storage (BLOB/BYTEA)</li>
     *   <li>Enum columns with flexible storage strategies</li>
     *   <li>Timestamp fields for audit purposes</li>
     *   <li>Default values and NOT NULL constraints</li>
     * </ul>
     *
     * <h4>Example Usage:</h4>
     * <pre>{@code
     * @Table(value = "users", dialect = Dialect.POSTGRESQL)
     * public class User {
     *     @Id(autoGenerated = true)
     *     private Long id;
     *
     *     @Column("user_name")
     *     @Default("Anonymous")
     *     private String name;
     *
     *     @JsonColumn
     *     private Map<String, Object> metadata;
     *
     *     @UUID
     *     private String uuid;
     *
     *     @CreatedDate
     *     private LocalDateTime createdAt;
     * }
     *
     * // Usage
     * UserCRUD crud = new UserCRUD(jdbi);
     * String ddl = crud.getTableCreationTemplate();
     * System.out.println(ddl);
     * }</pre>
     *
     * @return DDL CREATE TABLE statement as a string
     * @throws IllegalArgumentException if entity is not properly annotated
     */
    public String getTableCreationTemplate() {
        Table tableAnnotation = entityClass.getAnnotation(Table.class);
        if (tableAnnotation == null) {
            throw new IllegalArgumentException("Entity must be annotated with @Table");
        }

        String schema = tableAnnotation.schema();
        String table = tableAnnotation.value();
        Dialect tableDialect = tableAnnotation.dialect();

        String fullTableName = schema.isEmpty() ? table : schema + "." + table;

        StringBuilder ddl = new StringBuilder();
        ddl.append("-- Table creation template for: ").append(entityClass.getSimpleName()).append("\n");
        ddl.append("-- Database: ").append(tableDialect.name()).append("\n");
        ddl.append("-- Generated by CRUD Library \n\n");

        ddl.append("CREATE TABLE ").append(fullTableName).append(" (\n");

        List<String> columnDefinitions = new ArrayList<>();
        List<String> constraints = new ArrayList<>();
        String primaryKeyColumn = null;
        boolean hasAutoIncrement = false;

        Field[] fields = Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> !field.isAnnotationPresent(Ignore.class))
                .toArray(Field[]::new);

        for (Field field : fields) {
            String columnDef = generateColumnDefinition(field, tableDialect);
            columnDefinitions.add(columnDef);

            // Check for primary key
            if (field.isAnnotationPresent(Id.class)) {
                primaryKeyColumn = getColumnName(field);
                Id idAnnotation = field.getAnnotation(Id.class);
                hasAutoIncrement = idAnnotation.autoGenerated();
            }
        }

        // Join column definitions
        ddl.append("    ").append(String.join(",\n    ", columnDefinitions));

        // Add primary key constraint
        if (primaryKeyColumn != null) {
            ddl.append(",\n    CONSTRAINT pk_").append(table).append(" PRIMARY KEY (").append(primaryKeyColumn).append(")");
        }

        ddl.append("\n)");

        // Add dialect-specific options
        if (tableDialect == Dialect.MYSQL) {
            ddl.append(" ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci");
            if (hasAutoIncrement) {
                ddl.append(" AUTO_INCREMENT=1");
            }
        }

        ddl.append(";\n\n");

        // Add indexes suggestions
        ddl.append(generateIndexSuggestions(fields, table, tableDialect));

        // Add comments with field mapping
        ddl.append(generateFieldMappingComments(fields));

        return ddl.toString();
    }

    /**
     * Generates column definition for a single field.
     */
    private String generateColumnDefinition(Field field, Dialect dialect) {
        String columnName = getColumnName(field);
        String dataType = mapFieldToSqlType(field, dialect);

        StringBuilder columnDef = new StringBuilder();
        columnDef.append(columnName).append(" ").append(dataType);

        // Add constraints
        List<String> constraints = generateColumnConstraints(field, dialect);
        if (!constraints.isEmpty()) {
            columnDef.append(" ").append(String.join(" ", constraints));
        }

        // Add comments
        String comment = generateColumnComment(field);
        if (!comment.isEmpty()) {
            if (dialect == Dialect.MYSQL) {
                columnDef.append(" COMMENT '").append(comment).append("'");
            }
        }

        return columnDef.toString();
    }

    /**
     * Maps Java field types to SQL data types based on annotations and dialect.
     */
    private String mapFieldToSqlType(Field field, Dialect dialect) {
        Class<?> fieldType = field.getType();

        // UUID fields
        if (field.isAnnotationPresent(UUID.class)) {
            if (dialect == Dialect.POSTGRESQL) {
                return "UUID";
            } else {
                return "VARCHAR(36)";
            }
        }

        // JSON fields
        if (field.isAnnotationPresent(JsonColumn.class)) {
            if (dialect == Dialect.POSTGRESQL) {
                return "JSONB";
            } else {
                return "JSON";
            }
        }

        // Array fields (stored as delimited text)
        if (field.isAnnotationPresent(ArrayColumn.class)) {
            return "TEXT";
        }

        // File fields
        if (field.isAnnotationPresent(FileColumn.class)) {
            if (dialect == Dialect.POSTGRESQL) {
                return "BYTEA";
            } else {
                return "LONGBLOB";
            }
        }

        // Enum fields
        if (field.isAnnotationPresent(EnumColumn.class)) {
            EnumColumn enumAnnotation = field.getAnnotation(EnumColumn.class);
            return switch (enumAnnotation.value()) {
                case STRING -> "VARCHAR(50)";
                case ORDINAL -> "INT";
                case CODE -> "VARCHAR(10)"; // Assuming short codes
            };
        }

        // Standard Java types
        if (fieldType == String.class) {
            return "VARCHAR(255)";
        } else if (fieldType == Integer.class || fieldType == int.class) {
            return "INT";
        } else if (fieldType == Long.class || fieldType == long.class) {
            // Check if it's an ID field that might need BIGINT
            if (field.isAnnotationPresent(Id.class)) {
                return dialect == Dialect.POSTGRESQL ? "BIGSERIAL" : "BIGINT";
            }
            return "BIGINT";
        } else if (fieldType == Boolean.class || fieldType == boolean.class) {
            return dialect == Dialect.POSTGRESQL ? "BOOLEAN" : "TINYINT(1)";
        } else if (fieldType == Double.class || fieldType == double.class) {
            return "DOUBLE";
        } else if (fieldType == Float.class || fieldType == float.class) {
            return "FLOAT";
        } else if (fieldType == LocalDateTime.class) {
            return dialect == Dialect.POSTGRESQL ? "TIMESTAMP" : "DATETIME";
        } else if (fieldType == java.time.LocalDate.class) {
            return "DATE";
        } else if (fieldType == java.time.LocalTime.class) {
            return "TIME";
        } else if (fieldType == byte[].class) {
            return dialect == Dialect.POSTGRESQL ? "BYTEA" : "BLOB";
        } else if (fieldType == java.math.BigDecimal.class) {
            return "DECIMAL(19,2)";
        }

        // Default fallback
        return "VARCHAR(255)";
    }

    /**
     * Generates column constraints (NOT NULL, DEFAULT, AUTO_INCREMENT, etc.)
     */
    private List<String> generateColumnConstraints(Field field, Dialect dialect) {
        List<String> constraints = new ArrayList<>();

        // NOT NULL constraint
        if (field.isAnnotationPresent(Id.class) ||
                field.isAnnotationPresent(CreatedDate.class) ||
                field.isAnnotationPresent(UpdatedDate.class)) {
            constraints.add("NOT NULL");
        }

        // AUTO_INCREMENT for ID fields
        if (field.isAnnotationPresent(Id.class)) {
            Id idAnnotation = field.getAnnotation(Id.class);
            if (idAnnotation.autoGenerated()) {
                if (dialect == Dialect.MYSQL) {
                    constraints.add("AUTO_INCREMENT");
                }
                // PostgreSQL uses SERIAL/BIGSERIAL in type definition
            }
        }

        // DEFAULT values
        if (field.isAnnotationPresent(Default.class)) {
            Default defaultAnnotation = field.getAnnotation(Default.class);
            String defaultValue = formatDefaultValue(defaultAnnotation.value(), field.getType(), dialect);
            constraints.add("DEFAULT " + defaultValue);
        }

        // Timestamp defaults
        if (field.isAnnotationPresent(CreatedDate.class) || field.isAnnotationPresent(UpdatedDate.class)) {
            if (dialect == Dialect.POSTGRESQL) {
                constraints.add("DEFAULT CURRENT_TIMESTAMP");
            } else {
                constraints.add("DEFAULT CURRENT_TIMESTAMP");
            }
        }

        // UUID default generation
        if (field.isAnnotationPresent(UUID.class)) {
            UUID uuidAnnotation = field.getAnnotation(UUID.class);
            if (uuidAnnotation.autoGenerate()) {
                if (dialect == Dialect.POSTGRESQL) {
                    constraints.add("DEFAULT gen_random_uuid()");
                }
                // MySQL doesn't have built-in UUID generation
            }
        }

        return constraints;
    }

    /**
     * Formats default values according to data type and dialect.
     */
    private String formatDefaultValue(String value, Class<?> fieldType, Dialect dialect) {
        if (fieldType == String.class) {
            return "'" + value.replace("'", "''") + "'";
        } else if (fieldType == Boolean.class || fieldType == boolean.class) {
            if (dialect == Dialect.POSTGRESQL) {
                return value.toLowerCase();
            } else {
                return Boolean.parseBoolean(value) ? "1" : "0";
            }
        }
        return value; // Numbers don't need quotes
    }

    /**
     * Generates column comment based on annotations.
     */
    private String generateColumnComment(Field field) {
        StringBuilder comment = new StringBuilder();

        if (field.isAnnotationPresent(JsonColumn.class)) {
            comment.append("JSON data structure");
        } else if (field.isAnnotationPresent(ArrayColumn.class)) {
            ArrayColumn arrayAnnotation = field.getAnnotation(ArrayColumn.class);
            comment.append("Array stored as delimited text (separator: '").append(arrayAnnotation.separator()).append("')");
        } else if (field.isAnnotationPresent(UUID.class)) {
            comment.append("UUID identifier");
        } else if (field.isAnnotationPresent(FileColumn.class)) {
            comment.append("File binary data");
        } else if (field.isAnnotationPresent(EnumColumn.class)) {
            EnumColumn enumAnnotation = field.getAnnotation(EnumColumn.class);
            comment.append("Enum stored as ").append(enumAnnotation.value().name().toLowerCase());
        } else if (field.isAnnotationPresent(CreatedDate.class)) {
            comment.append("Record creation timestamp");
        } else if (field.isAnnotationPresent(UpdatedDate.class)) {
            comment.append("Record last update timestamp");
        }

        return comment.toString();
    }

    /**
     * Generates index suggestions based on field types and annotations.
     */
    private String generateIndexSuggestions(Field[] fields, String tableName, Dialect dialect) {
        StringBuilder indexes = new StringBuilder();
        indexes.append("-- Suggested indexes:\n");

        for (Field field : fields) {
            String columnName = getColumnName(field);

            // UUID fields often need indexes
            if (field.isAnnotationPresent(UUID.class)) {
                indexes.append("CREATE INDEX idx_").append(tableName).append("_").append(columnName)
                        .append(" ON ").append(tableName).append(" (").append(columnName).append(");\n");
            }

            // Timestamp fields for queries
            if (field.isAnnotationPresent(CreatedDate.class) || field.isAnnotationPresent(UpdatedDate.class)) {
                indexes.append("CREATE INDEX idx_").append(tableName).append("_").append(columnName)
                        .append(" ON ").append(tableName).append(" (").append(columnName).append(");\n");
            }

            // JSON fields might need GIN indexes in PostgreSQL
            if (field.isAnnotationPresent(JsonColumn.class) && dialect == Dialect.POSTGRESQL) {
                indexes.append("CREATE INDEX idx_").append(tableName).append("_").append(columnName)
                        .append("_gin ON ").append(tableName).append(" USING GIN (").append(columnName).append(");\n");
            }
        }

        return indexes.append("\n").toString();
    }

    /**
     * Generates comments explaining field mappings and annotations.
     */
    private String generateFieldMappingComments(Field[] fields) {
        StringBuilder comments = new StringBuilder();
        comments.append("-- Field Mapping Reference:\n");
        comments.append("-- ").append(String.format("%-20s %-20s %-30s %s", "Java Field", "Column Name", "Type", "Annotations")).append("\n");
        comments.append("-- ").append("-".repeat(90)).append("\n");

        for (Field field : fields) {
            String fieldName = field.getName();
            String columnName = getColumnName(field);
            String javaType = field.getType().getSimpleName();

            List<String> annotations = new ArrayList<>();
            if (field.isAnnotationPresent(Id.class)) annotations.add("@Id");
            if (field.isAnnotationPresent(Column.class)) annotations.add("@Column");
            if (field.isAnnotationPresent(JsonColumn.class)) annotations.add("@JsonColumn");
            if (field.isAnnotationPresent(ArrayColumn.class)) annotations.add("@ArrayColumn");
            if (field.isAnnotationPresent(UUID.class)) annotations.add("@UUID");
            if (field.isAnnotationPresent(EnumColumn.class)) annotations.add("@EnumColumn");
            if (field.isAnnotationPresent(FileColumn.class)) annotations.add("@FileColumn");
            if (field.isAnnotationPresent(CreatedDate.class)) annotations.add("@CreatedDate");
            if (field.isAnnotationPresent(UpdatedDate.class)) annotations.add("@UpdatedDate");
            if (field.isAnnotationPresent(Default.class)) annotations.add("@Default");
            if (field.isAnnotationPresent(Ignore.class)) annotations.add("@Ignore");

            comments.append("-- ").append(String.format("%-20s %-20s %-30s %s",
                    fieldName, columnName, javaType, String.join(", ", annotations))).append("\n");
        }

        return comments.toString();
    }


    // ================================
    // AUTOMATIC SQL GENERATION
    // ================================

    /**
     * Builds the INSERT SQL statement for this entity.
     * <p>
     * The SQL is generated based on entity annotations and cached for performance.
     * Only non-ignored fields and non-auto-generated ID fields are included.
     * </p>
     *
     * @return the INSERT SQL statement
     */
    protected String buildInsertSql() {
        return insertSqlCache.computeIfAbsent(entityClass, clazz -> {
            Field[] fields = getInsertableFields();

            StringJoiner columns = new StringJoiner(", ");
            StringJoiner placeholders = new StringJoiner(", ");

            for (Field field : fields) {
                String columnName = getColumnName(field);
                columns.add(columnName);
                String placeholder = ":" + field.getName();

                // Si el dialecto es PostgreSQL y es un JSON column, agregamos ::jsonb
                if (dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(JsonColumn.class)) {
                    placeholder += "::jsonb";
                }
                if(dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(UUID.class)) {
                    UUID uuidAnnotation = field.getAnnotation(UUID.class);
                    if(!uuidAnnotation.autoGenerate()){
                        placeholder += "::uuid";
                    }
                }

                placeholders.add(placeholder);
            }

            return "INSERT INTO " + tableName + " (" + columns + ") VALUES (" + placeholders + ")";
        });
    }

    /**
     * Builds the UPDATE SQL statement for this entity.
     * <p>
     * The SQL is generated based on entity annotations and cached for performance.
     * CreatedDate fields are excluded from updates, but UpdatedDate fields are included.
     * </p>
     *
     * @return the UPDATE SQL statement
     */
    protected String buildUpdateSql() {
        return updateSqlCache.computeIfAbsent(entityClass, clazz -> {
            Field[] fields = getUpdatableFields();
            Field idField = getIdField();

            StringJoiner setClauses = new StringJoiner(", ");

            for (Field field : fields) {
                if (!field.equals(idField) && !field.isAnnotationPresent(CreatedDate.class)) {
                    String columnName = getColumnName(field);
                    String placeholder = ":" + field.getName();

                    if (dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(JsonColumn.class)) {
                        placeholder += "::jsonb";
                    }

                    if (dialect == Dialect.POSTGRESQL && field.isAnnotationPresent(UUID.class)) {
                        UUID uuidAnnotation = field.getAnnotation(UUID.class);
                        if (!uuidAnnotation.autoGenerate()) {
                            placeholder += "::uuid";
                        }
                    }

                    setClauses.add(columnName + " = " + placeholder);
                }
            }

            return "UPDATE " + tableName + " SET " + setClauses + " WHERE " + getIdColumnName() + " = :" + idField.getName();
        });
    }

    // ================================
    // AUTOMATIC PARAMETER BINDING WITH TRANSFORMATIONS
    // ================================

    /**
     * Binds parameters for INSERT operations with automatic transformations.
     * <p>
     * Processes the entity by generating UUIDs, setting defaults, and timestamps
     * before binding parameters to the statement.
     * </p>
     *
     * @param update the JDBI Update statement
     * @param entity the entity to bind
     */
    protected void bindInsertParameters(Update update, E entity) {
        processEntityForInsert(entity);
        bindParameters(update, entity, getInsertableFields());
    }

    /**
     * Binds parameters for UPDATE operations with automatic transformations.
     * <p>
     * Processes the entity by updating timestamps before binding parameters.
     * </p>
     *
     * @param update the JDBI Update statement
     * @param entity the entity to bind
     */
    protected void bindUpdateParameters(Update update, E entity) {
        processEntityForUpdate(entity);
        bindParameters(update, entity, getAllFields());
    }

    /**
     * Binds parameters for BATCH operations with automatic transformations.
     *
     * @param batch the JDBI PreparedBatch statement
     * @param entity the entity to bind
     */
    protected void bindBatchParameters(PreparedBatch batch, E entity) {
        processEntityForInsert(entity);
        bindParameters(batch, entity, getInsertableFields());
    }

    /**
     * Binds field values to statement parameters with type transformations.
     *
     * @param statement the JDBI statement (Update or PreparedBatch)
     * @param entity the entity containing values
     * @param fields the fields to bind
     */
    private void bindParameters(Object statement, E entity, Field[] fields) {
        for (Field field : fields) {
            try {
                field.setAccessible(true);
                Object value = field.get(entity);
                Object processedValue = processFieldValue(field, value);

                if (statement instanceof Update) {
                    ((Update) statement).bind(field.getName(), processedValue);
                } else if (statement instanceof PreparedBatch) {
                    ((PreparedBatch) statement).bind(field.getName(), processedValue);
                }
            } catch (IllegalAccessException e) {
                throw new RuntimeException("Error accessing field: " + field.getName(), e);
            }
        }
    }

    // ================================
    // AUTOMATIC FIELD PROCESSING
    // ================================

    /**
     * Processes entity fields before INSERT operations.
     * <p>
     * Performs the following operations in order:
     * <ol>
     *   <li>Generate UUIDs for @UUID annotated fields</li>
     *   <li>Set default values for @Default annotated fields</li>
     *   <li>Set timestamps for @CreatedDate and @UpdatedDate fields</li>
     * </ol>
     * </p>
     *
     * @param entity the entity to process
     */
    private void processEntityForInsert(E entity) {
        generateUUIDs(entity);
        setDefaultValues(entity);
        setTimestamp(entity, CreatedDate.class);
        setTimestamp(entity, UpdatedDate.class);
    }

    /**
     * Processes entity fields before UPDATE operations.
     * <p>
     * Only updates @UpdatedDate fields with the current timestamp.
     * </p>
     *
     * @param entity the entity to process
     */
    private void processEntityForUpdate(E entity) {
        setTimestamp(entity, UpdatedDate.class);
    }

    /**
     * Generates UUIDs for @UUID annotated fields that are null.
     *
     * @param entity the entity to process
     */
    private void generateUUIDs(E entity) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(UUID.class))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        Object currentValue = field.get(entity);

                        if (currentValue == null) {
                            UUID uuidAnnotation = field.getAnnotation(UUID.class);
                            if (uuidAnnotation.autoGenerate()) {
                                if(field.getType() == String.class){
                                    field.set(entity, java.util.UUID.randomUUID().toString());
                                }else if(field.getType() == java.util.UUID.class){
                                    field.set(entity, java.util.UUID.randomUUID());
                                }
                            }
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error generating UUID for field: " + field.getName(), e);
                    }
                });
    }

    /**
     * Sets default values for @Default annotated fields that are null.
     *
     * @param entity the entity to process
     */
    private void setDefaultValues(E entity) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(Default.class))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        Object currentValue = field.get(entity);

                        if (currentValue == null) {
                            Default defaultAnnotation = field.getAnnotation(Default.class);
                            Object defaultValue = convertStringToFieldType(defaultAnnotation.value(), field.getType());
                            field.set(entity, defaultValue);
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error setting default value for field: " + field.getName(), e);
                    }
                });
    }

    /**
     * Sets timestamp fields with the current LocalDateTime.
     *
     * @param entity the entity to process
     * @param annotationClass the timestamp annotation class (CreatedDate or UpdatedDate)
     */
    private void setTimestamp(E entity, Class<? extends java.lang.annotation.Annotation> annotationClass) {
        Arrays.stream(entityClass.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(annotationClass))
                .forEach(field -> {
                    try {
                        field.setAccessible(true);
                        if (field.getType() == LocalDateTime.class) {
                            field.set(entity, LocalDateTime.now());
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Error setting timestamp for field: " + field.getName(), e);
                    }
                });
    }

    // ================================
    // TYPE TRANSFORMATIONS
    // ================================

    /**
     * Processes field values with type-specific transformations.
     * <p>
     * Handles the following transformations:
     * <ul>
     *   <li>@JsonColumn: Serializes objects to JSON strings</li>
     *   <li>@ArrayColumn: Joins arrays/lists with specified separator</li>
     *   <li>@EnumColumn: Converts enums based on storage strategy</li>
     * </ul>
     * </p>
     *
     * @param field the field being processed
     * @param value the field value
     * @return the transformed value for database storage
     */
    private Object processFieldValue(Field field, Object value) {
        if (value == null) return null;

        // JSON Column serialization
        if (field.isAnnotationPresent(JsonColumn.class) && !(value instanceof String)) {
            try {
                return objectMapper.writeValueAsString(value);
            } catch (Exception e) {
                throw new RuntimeException("Error serializing JSON field: " + field.getName(), e);
            }
        }

        // Array Column joining
        if (field.isAnnotationPresent(ArrayColumn.class)) {
            ArrayColumn arrayAnnotation = field.getAnnotation(ArrayColumn.class);
            if (value instanceof List) {
                return String.join(arrayAnnotation.separator(),
                        ((List<?>) value).stream().map(Object::toString).toArray(String[]::new));
            } else if (value instanceof String[]) {
                return String.join(arrayAnnotation.separator(), (String[]) value);
            }
        }

        // Enum Column transformation
        if (field.isAnnotationPresent(EnumColumn.class) && value instanceof Enum) {
            EnumColumn enumAnnotation = field.getAnnotation(EnumColumn.class);
            Enum<?> enumValue = (Enum<?>) value;
            switch (enumAnnotation.value()) {
                case STRING:
                    return enumValue.name();
                case ORDINAL:
                    return enumValue.ordinal();
                case CODE:
                    try {
                        Method getCodeMethod = enumValue.getClass().getMethod("getCode");
                        return getCodeMethod.invoke(enumValue);
                    } catch (Exception e) {
                        throw new IllegalStateException(
                                "The enum " + enumValue.getClass().getName() +
                                        " must have a getCode() method for @EnumColumn(EnumType.CODE)", e
                        );
                    }
                default:
                    return enumValue.ordinal();
            }
        }

        return value;
    }

    // ================================
    // REFLECTION UTILITIES WITH CACHING
    // ================================

    /**
     * Gets fields that should be included in INSERT statements.
     * <p>
     * Excludes @Ignore fields and auto-generated @Id fields.
     * Results are cached for performance.
     * </p>
     *
     * @return array of insertable fields
     */
    private Field[] getInsertableFields() {
        return insertableFieldsCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> !field.isAnnotationPresent(Ignore.class))
                        .filter(field -> {
                            Id idAnnotation = field.getAnnotation(Id.class);
                            return idAnnotation == null || !idAnnotation.autoGenerated();
                        })
                        .toArray(Field[]::new)
        );
    }

    /**
     * Gets fields that should be included in UPDATE statements.
     * <p>
     * Excludes only @Ignore fields. Results are cached for performance.
     * </p>
     *
     * @return array of updatable fields
     */
    private Field[] getUpdatableFields() {
        return updatableFieldsCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> !field.isAnnotationPresent(Ignore.class))
                        .toArray(Field[]::new)
        );
    }

    /**
     * Gets all declared fields of the entity class.
     *
     * @return array of all fields
     */
    private Field[] getAllFields() {
        return entityClass.getDeclaredFields();
    }

    /**
     * Gets the @Id annotated field from the entity class.
     * <p>
     * Results are cached for performance.
     * </p>
     *
     * @return the ID field
     * @throws RuntimeException if no @Id field is found
     */
    private Field getIdField() {
        return idFieldCache.computeIfAbsent(entityClass, clazz ->
                Arrays.stream(clazz.getDeclaredFields())
                        .filter(field -> field.isAnnotationPresent(Id.class))
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("No @Id field found in " + clazz.getName()))
        );
    }

    /**
     * Gets the database column name for a field.
     * <p>
     * Uses @Column annotation value if present, otherwise uses field name.
     * </p>
     *
     * @param field the field to get column name for
     * @return the column name
     */
    private String getColumnName(Field field) {
        Column column = field.getAnnotation(Column.class);
        return column != null && !column.value().isEmpty() ? column.value() : field.getName();
    }
    // ================================

    // Provider EXTENSIONS
    // ================================

    /**
     * Provider interface for supplying Jdbi instances.
     * <p>
     * Implement this interface to provide Jdbi instances from different sources,
     * such as dependency injection frameworks or application contexts.
     * </p>
     */
    public interface JdbiProvider{
        Jdbi getJdbi();
    }



    // ================================
    // CRUD OPERATIONS
    // ================================

    /**
     * Counts the total number of records in the table.
     *
     * @return the total record count
     */
    public long count() {
        return getConfiguredJdbi().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM " + tableName)
                        .mapTo(Long.class)
                        .one()
        );
    }

    /**
     * Retrieves all records from the table.
     *
     * @return list of all entities
     */
    public List<E> findAll() {
        return getConfiguredJdbi().withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName)
                        .map(getRowMapper())
                        .list()
        );
    }

    /**
     * Retrieves a limited number of records with pagination.
     *
     * @param limit the maximum number of records to return
     * @param offset the number of records to skip
     * @return list of entities within the specified range
     */
    public List<E> findAll(int limit, int offset) {
        return getConfiguredJdbi().withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " LIMIT :limit OFFSET :offset")
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .map(getRowMapper())
                        .list()
        );
    }

    /**
     * Finds an entity by its primary key.
     *
     * @param id the primary key value
     * @return Optional containing the entity if found, empty otherwise
     */
    public Optional<E> findById(ID id) {
        return getConfiguredJdbi().withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " WHERE " + getIdColumnName() + " = :id")
                        .bind("id", id)
                        .map(getRowMapper())
                        .findOne()
        );
    }

    /**
     * Checks if an entity with the given ID exists.
     *
     * @param id the primary key value
     * @return true if entity exists, false otherwise
     */
    public boolean existsById(ID id) {
        return getConfiguredJdbi().withHandle(handle -> {
                    String sql = "SELECT 1 FROM " + tableName + " WHERE " + getIdColumnName() + " = :id LIMIT 1";
                   return  handle.createQuery(sql)
                            .bind("id", id)
                            .mapTo(Integer.class)
                            .findOne()
                            .isPresent();
                }
        );
    }

    /**
     * Saves an entity to the database.
     * <p>
     * For auto-generated IDs, the generated key is returned. For manual IDs,
     * the entity's ID value is returned. The entity is processed automatically
     * (UUIDs generated, defaults set, timestamps updated).
     * </p>
     *
     * @param entity the entity to save
     * @return the primary key of the saved entity
     */
    public ID save(E entity) {
        return getConfiguredJdbi().inTransaction(handle -> {
            String sql = buildInsertSql();
            Update update = handle.createUpdate(sql);
            bindInsertParameters(update, entity);

            Field idField = getIdField();
            Id idAnnotation = idField.getAnnotation(Id.class);

            if (idAnnotation.autoGenerated()) {
                return update.executeAndReturnGeneratedKeys(getIdColumnName())
                        .mapTo(getIdType())
                        .one();
            } else {
                update.execute();
                try {
                    idField.setAccessible(true);
                    return getIdType().cast(idField.get(entity));
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Error accessing ID field", e);
                }
            }
        });
    }

    /**
     * Saves multiple entities in a single transaction.
     * <p>
     * Each entity is processed individually and saved. If any save fails,
     * the entire transaction is rolled back.
     * </p>
     *
     * @param entities the list of entities to save
     */
    public void saveAll(List<E> entities) {
        if (entities == null || entities.isEmpty()) {
            return;
        }

        getConfiguredJdbi().inTransaction(handle -> {
            String sql = buildInsertSql();
            for (E entity : entities) {
                Update update = handle.createUpdate(sql);
                bindInsertParameters(update, entity);
                update.execute();
            }
            return null;
        });
    }

    /**
     * Updates an existing entity in the database.
     * <p>
     * The entity must have a valid ID. UpdatedDate fields are automatically
     * updated to the current timestamp.
     * </p>
     *
     * @param entity the entity to update
     * @return true if the entity was updated, false if no matching record was found
     */
    public boolean update(E entity) {
        return getConfiguredJdbi().inTransaction(handle -> {
            String sql = buildUpdateSql();
            Update update = handle.createUpdate(sql);
            bindUpdateParameters(update, entity);
            return update.execute() > 0;
        });
    }

    /**
     * Deletes an entity by its primary key.
     *
     * @param id the primary key of the entity to delete
     * @return true if the entity was deleted, false if no matching record was found
     */
    public boolean deleteById(ID id) {
        return getConfiguredJdbi().inTransaction(handle ->{
                    String sql = "DELETE FROM " + tableName + " WHERE " + getIdColumnName() + " = :id";
                    return handle.createUpdate(sql)
                            .bind("id", id)
                            .execute() > 0;
                }
        );
    }

    /**
     * Deletes all entities from the table.
     * <p>
     * <strong>WARNING:</strong> This operation cannot be undone!
     * </p>
     *
     * @return the number of deleted records
     */
    public int deleteAll() {
        return getConfiguredJdbi().inTransaction(handle ->{
                    String sql = "DELETE FROM " + tableName;
                    return  handle.createUpdate(sql)
                            .execute();
                }
        );

    }

    // ================================
    // UTILITIES
    // ================================

    /**
     * Converts a string value to the specified field type.
     * <p>
     * Used internally for processing @Default annotation values.
     * Supports basic primitive types and their wrapper classes.
     * </p>
     *
     * @param value the string value to convert
     * @param fieldType the target field type
     * @return the converted value
     * @throws NumberFormatException if numeric conversion fails
     */
    private Object convertStringToFieldType(String value, Class<?> fieldType) {
        if (fieldType == String.class) return value;
        if (fieldType == Integer.class || fieldType == int.class) return Integer.valueOf(value);
        if (fieldType == Long.class || fieldType == long.class) return Long.valueOf(value);
        if (fieldType == Boolean.class || fieldType == boolean.class) return Boolean.valueOf(value);
        if (fieldType == Double.class || fieldType == double.class) return Double.valueOf(value);
        // Add more types as needed
        return value;
    }

    public <E> E mapRow(ResultSet rs, Class<E> entityClass) throws SQLException {
        try {
            E entity = entityClass.getDeclaredConstructor().newInstance();

            for (Field field : entityClass.getDeclaredFields()) {
                if (field.isAnnotationPresent(Ignore.class)) continue;

                field.setAccessible(true);
                String columnName = getColumnName(field);

                Object value = null;

                if (field.isAnnotationPresent(UUID.class)) {
                    if (dialect == Dialect.POSTGRESQL) {
                        value = rs.getObject(columnName, java.util.UUID.class);
                        if(value != null && field.getType() == String.class){
                            value = value.toString();
                        }
                    } else {
                        value = rs.getString(columnName);
                    }
                } else if (field.isAnnotationPresent(JsonColumn.class)) {
                    String json = rs.getString(columnName);
                    if (json != null) {
                        Class<?> fieldType = field.getType();
                        if (Map.class.isAssignableFrom(fieldType)) {
                            value = new ObjectMapper().readValue(json, new TypeReference<Map<String,Object>>() {});
                        } else if (JsonNode.class.isAssignableFrom(fieldType)) {
                            value = new ObjectMapper().readTree(json);
                        } else {
                            value = new ObjectMapper().readValue(json, fieldType);
                        }
                    }
                } else if (field.isAnnotationPresent(ArrayColumn.class)) {
                    ArrayColumn arrayAnno = field.getAnnotation(ArrayColumn.class);
                    String[] array = Optional.ofNullable(rs.getString(columnName)).orElse("").split(arrayAnno.separator());
                    if (List.class.isAssignableFrom(field.getType())) {
                        value = Arrays.asList(array);
                    } else if (field.getType().isArray()) {
                        value = array;
                    }
                } else if (field.isAnnotationPresent(EnumColumn.class)) {
                    EnumColumn enumAnno = field.getAnnotation(EnumColumn.class);
                    String raw = rs.getString(columnName);
                    if (raw != null) {
                        value = mapEnum(field.getType(), raw, enumAnno.value());
                    }
                } else if (field.isAnnotationPresent(FileColumn.class)) {
                    value = rs.getBytes(columnName);
                } else if (field.getType().equals(LocalDateTime.class)) {
                    Timestamp ts = rs.getTimestamp(columnName);
                    if (ts != null) value = ts.toLocalDateTime();
                } else {
                    value = rs.getObject(columnName);
                }

                // Aplicar default si null
                if (value == null && field.isAnnotationPresent(Default.class)) {
                    Default def = field.getAnnotation(Default.class);
                    value = parseDefaultValue(def.value(), field.getType());
                }

                field.set(entity, value);
            }

            return entity;

        } catch (Exception e) {
            throw new RuntimeException("Error mapping ResultSet to " + entityClass.getSimpleName(), e);
        }
    }

    private Object mapEnum(Class<?> enumClass, String raw, EnumColumn.EnumType type) {
        Object[] constants = enumClass.getEnumConstants();
        switch (type) {
            case STRING:
                for (Object c : constants) if (((Enum<?>) c).name().equals(raw)) return c;
                break;
            case ORDINAL:
                int idx = Integer.parseInt(raw);
                return constants[idx];
            case CODE:
                for (Object c : constants) {
                    try {
                        Method getCode = c.getClass().getMethod("getCode");
                        if (getCode.invoke(c).toString().equals(raw)) return c;
                    } catch (Exception ignored) {}
                }
                break;
        }
        return null;
    }

    private Object parseDefaultValue(String def, Class<?> type) {
        if (type.equals(String.class)) return def;
        if (type.equals(Boolean.class) || type.equals(boolean.class)) return Boolean.parseBoolean(def);
        if (type.equals(Integer.class) || type.equals(int.class)) return Integer.parseInt(def);
        if (type.equals(Long.class) || type.equals(long.class)) return Long.parseLong(def);
        return null;
    }

}