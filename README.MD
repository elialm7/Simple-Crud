# CRUD Library - Complete Documentation

A lightweight, annotation-driven CRUD library for Java with automatic SQL generation and type transformations.

## Features

- **Zero configuration** - Define your entities with annotations
- **Automatic SQL generation** - INSERT/UPDATE/SELECT statements created automatically
- **Type transformations** - JSON, Arrays, Enums, UUIDs handled automatically
- **Performance optimized** - Metadata caching and prepared statements
- **Transaction support** - Full transaction control with isolation levels
- **Batch operations** - High-performance batch inserts

## Complete Example

Here's a comprehensive example using ALL available annotations:

### Entity Definition

```java
@Table(value = "complex_entities", schema = "main")
public class ComplexEntity {

    // Auto-generated primary key
    @Id(autoGenerated = true)
    private Long id;

    // Manual ID (for cases where you provide the ID)
    // @Id(autoGenerated = false)
    // private String customId;

    // Basic column mapping
    @Column("entity_name")
    private String name;

    // UUID auto-generation
    @UUID(autoGenerate = true)
    @Column("uuid_field")
    private String uuid;

    // Manual UUID (when you want to provide it)
    @UUID(autoGenerate = false)
    private String manualUuid;

    // JSON serialization - supports Objects, Maps, JsonNode
    @JsonColumn
    @Column("preferences_json")
    private UserPreferences preferences;  // Custom object

    @JsonColumn
    private Map<String, Object> metadata;  // Map

    @JsonColumn
    private JsonNode rawJson;  // JsonNode

    // Array handling
    @ArrayColumn(separator = ",")
    private List<String> tags;

    @ArrayColumn(separator = "|")
    private String[] categories;

    // Enum handling - STRING mode
    @EnumColumn(EnumColumn.EnumType.STRING)
    private Status status;

    // Enum handling - ORDINAL mode  
    @EnumColumn(EnumColumn.EnumType.ORDINAL)
    private Priority priority;

    // Enum handling - CODE mode (requires getCode() method)
    @EnumColumn(EnumColumn.EnumType.CODE)
    private Department department;

    // File storage
    @FileColumn
    private byte[] document;

    // Default values
    @Default("true")
    private Boolean active;

    @Default("0")
    private Integer attempts;

    // Automatic timestamps
    @CreatedDate
    private LocalDateTime createdAt;

    @UpdatedDate
    private LocalDateTime updatedAt;

    // Ignored field (not persisted)
    @Ignore
    private String temporaryField;

    // Constructors, getters, setters...
}
```

### Supporting Classes

```java
// Custom object for JSON serialization
public class UserPreferences {
    private String theme;
    private boolean notifications;
    private Map<String, String> settings;
    // getters/setters...
}

// Enum with STRING mode
public enum Status {
    ACTIVE, INACTIVE, PENDING, SUSPENDED
}

// Enum with ORDINAL mode  
public enum Priority {
    LOW, MEDIUM, HIGH, CRITICAL  // Stored as 0,1,2,3
}

// Enum with CODE mode (requires getCode() method)
public enum Department {
    SALES("SALE"), MARKETING("MKTG"), ENGINEERING("ENG"), HR("HRES");

    private final String code;
    Department(String code) { this.code = code; }
    public String getCode() { return code; }  // Required for CODE mode
}
```

### CRUD Implementation

```java
public class ComplexEntityCRUD extends CRUD<ComplexEntity, Long> {

    public ComplexEntityCRUD(Jdbi jdbi) {
        super(jdbi, ComplexEntity.class, Long.class);
    }

    // Add custom methods as needed
    public List<ComplexEntity> findActiveEntities() {
        return jdbi.withHandle(handle ->
                handle.createQuery("SELECT * FROM " + tableName + " WHERE active = true")
                        .map(getRowMapper())
                        .list()
        );
    }
}
```

## Database Schema

### PostgreSQL

```sql
-- Complete schema with all annotation types
CREATE SCHEMA IF NOT EXISTS main;

CREATE TABLE main.complex_entities (
    -- Auto-generated ID
                                       id BIGSERIAL PRIMARY KEY,

    -- Basic columns
                                       entity_name VARCHAR(255),
                                       uuid_field UUID,
                                       manual_uuid UUID,

    -- JSON columns (PostgreSQL native JSON)
                                       preferences_json JSONB,
                                       metadata JSONB,
                                       raw_json JSONB,

    -- Array columns (stored as TEXT)
                                       tags TEXT,                    -- comma-separated: "tag1,tag2,tag3"
                                       categories TEXT,              -- pipe-separated: "cat1|cat2|cat3"

    -- Enum columns
                                       status VARCHAR(50),           -- STRING mode: "ACTIVE", "INACTIVE"
                                       priority INTEGER,             -- ORDINAL mode: 0, 1, 2, 3
                                       department VARCHAR(10),       -- CODE mode: "SALE", "MKTG", "ENG"

    -- File storage
                                       document BYTEA,

    -- Default values
                                       active BOOLEAN DEFAULT true,
                                       attempts INTEGER DEFAULT 0,

    -- Automatic timestamps
                                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                                       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Trigger for updated_at (PostgreSQL)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_complex_entities_updated_at
    BEFORE UPDATE ON main.complex_entities
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### MySQL

```sql
-- Complete schema with all annotation types
CREATE DATABASE IF NOT EXISTS main;
USE main;

CREATE TABLE complex_entities (
    -- Auto-generated ID
                                  id BIGINT AUTO_INCREMENT PRIMARY KEY,

    -- Basic columns
                                  entity_name VARCHAR(255),
                                  uuid_field VARCHAR(36),       -- UUID as string in MySQL
                                  manual_uuid VARCHAR(36),

    -- JSON columns (MySQL 5.7+ native JSON)
                                  preferences_json JSON,
                                  metadata JSON,
                                  raw_json JSON,

    -- Array columns (stored as TEXT)
                                  tags TEXT,                    -- comma-separated: "tag1,tag2,tag3"
                                  categories TEXT,              -- pipe-separated: "cat1|cat2|cat3"

    -- Enum columns
                                  status VARCHAR(50),           -- STRING mode: "ACTIVE", "INACTIVE"  
                                  priority INT,                 -- ORDINAL mode: 0, 1, 2, 3
                                  department VARCHAR(10),       -- CODE mode: "SALE", "MKTG", "ENG"

    -- File storage
                                  document LONGBLOB,

    -- Default values
                                  active BOOLEAN DEFAULT TRUE,
                                  attempts INT DEFAULT 0,

    -- Automatic timestamps  
                                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                                  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

## Usage Examples

### Basic Operations

```java
// Initialize
Jdbi jdbi = Jdbi.create("jdbc:postgresql://localhost/mydb", "user", "pass");
ComplexEntityCRUD crud = new ComplexEntityCRUD(jdbi);

// Create entity
ComplexEntity entity = new ComplexEntity();
entity.setName("Test Entity");
entity.setPreferences(new UserPreferences("dark", true, Map.of("lang", "en")));
        entity.setMetadata(Map.of("version", "1.0", "author", "john"));
        entity.setTags(List.of("important", "test", "demo"));
        entity.setStatus(Status.ACTIVE);
entity.setPriority(Priority.HIGH);
entity.setDepartment(Department.ENGINEERING);

// Save (ID auto-generated, UUID auto-generated, timestamps set automatically)
Long id = crud.save(entity);

// Find
Optional<ComplexEntity> found = crud.findById(id);
List<ComplexEntity> all = crud.findAll();

// Update (updated_at set automatically)
entity.setName("Updated Name");
crud.update(entity);

// Delete
crud.deleteById(id);
```

### Batch Operations

```java
List<ComplexEntity> entities = Arrays.asList(entity1, entity2, entity3);
crud.saveAllBatch(entities);  // High-performance batch insert
```

### Transactions

```java
crud.executeInTransaction(handle -> {
        // Multiple operations in single transaction
        crud.save(entity1);
    crud.save(entity2);
    return null;
            });
```

## Annotation Reference

| Annotation | Purpose | Parameters | Example |
|------------|---------|------------|---------|
| `@Table` | Define table name | `value`, `schema` | `@Table(value="users", schema="main")` |
| `@Column` | Map field to column | `value` | `@Column("user_name")` |
| `@Id` | Primary key | `autoGenerated` | `@Id(autoGenerated=false)` |
| `@UUID` | UUID generation | `autoGenerate` | `@UUID(autoGenerate=true)` |
| `@JsonColumn` | JSON serialization | None | `@JsonColumn` |
| `@ArrayColumn` | Array handling | `separator` | `@ArrayColumn(separator="\|")` |
| `@EnumColumn` | Enum handling | `value` (STRING/ORDINAL/CODE) | `@EnumColumn(EnumType.CODE)` |
| `@FileColumn` | File storage | None | `@FileColumn` |
| `@Default` | Default value | `value` | `@Default("true")` |
| `@CreatedDate` | Creation timestamp | None | `@CreatedDate` |
| `@UpdatedDate` | Update timestamp | None | `@UpdatedDate` |
| `@Ignore` | Skip field | None | `@Ignore` |

## Data Type Handling

### Complete Type Mapping

| Java Type | PostgreSQL | MySQL | Notes |
|-----------|------------|-------|-------|
| `String` | `VARCHAR(n)`, `TEXT` | `VARCHAR(n)`, `TEXT` | Direct mapping, choose size based on content |
| `Long` | `BIGINT` | `BIGINT` | 64-bit integers |
| `Integer` | `INTEGER` | `INT` | 32-bit integers |
| `Short` | `SMALLINT` | `SMALLINT` | 16-bit integers |
| `Boolean` | `BOOLEAN` | `BOOLEAN`, `TINYINT(1)` | PostgreSQL native, MySQL uses TINYINT |
| `BigDecimal` | `NUMERIC(p,s)` | `DECIMAL(p,s)` | Precision numbers, specify precision/scale |
| `Double` | `DOUBLE PRECISION` | `DOUBLE` | 64-bit floating point |
| `Float` | `REAL` | `FLOAT` | 32-bit floating point |
| `byte[]` | `BYTEA` | `LONGBLOB` | Binary data with `@FileColumn` |

### Date/Time Handling (Critical!)

| Java Type | PostgreSQL | MySQL | Timezone Behavior | Notes |
|-----------|------------|-------|-------------------|-------|
| `LocalDateTime` | `TIMESTAMP` | `TIMESTAMP` | **No timezone** | ⚠️ Always stores as-is, no conversion |
| `LocalDate` | `DATE` | `DATE` | **No timezone** | Date only (2023-12-25) |
| `LocalTime` | `TIME` | `TIME` | **No timezone** | Time only (14:30:00) |
| `Instant` | `TIMESTAMPTZ` | `TIMESTAMP` | **UTC stored** | ⚠️ MySQL doesn't have timezone support |
| `ZonedDateTime` | `TIMESTAMPTZ` | `TIMESTAMP` | **Converts to UTC** | ⚠️ MySQL loses timezone info |
| `OffsetDateTime` | `TIMESTAMPTZ` | `TIMESTAMP` | **Converts to UTC** | ⚠️ MySQL loses timezone info |

#### Date/Time Best Practices

```java
// ✅ RECOMMENDED: Use LocalDateTime for audit fields
@CreatedDate
private LocalDateTime createdAt;  // Stores server time as-is

@UpdatedDate  
private LocalDateTime updatedAt;  // Updates to current server time

// ✅ RECOMMENDED: Use Instant for UTC timestamps
private Instant eventTimestamp;   // Always UTC, timezone-safe

// ⚠️ CAREFUL: ZonedDateTime with MySQL
private ZonedDateTime scheduledFor;  // Will lose timezone in MySQL!

// ✅ SAFE: LocalDate for date-only fields
private LocalDate birthDate;      // No time, no timezone issues
```

### JSON Data Types

| Java Type | PostgreSQL | MySQL | Performance | Notes |
|-----------|------------|-------|-------------|-------|
| `Object` (custom) | `JSONB` | `JSON` | Fast queries | Auto-serialized with Jackson |
| `Map<String,Object>` | `JSONB` | `JSON` | Fast queries | Dynamic key-value data |
| `JsonNode` | `JSONB` | `JSON` | Fast queries | Raw JSON manipulation |
| `List<Object>` | `JSONB` | `JSON` | Moderate | JSON arrays |

```java
// ✅ Custom objects (recommended)
@JsonColumn
private UserPreferences preferences;

// ✅ Dynamic data
@JsonColumn  
private Map<String, Object> metadata;

// ✅ Raw JSON processing
@JsonColumn
private JsonNode rawData;
```

### Array Handling

| Java Type | PostgreSQL | MySQL | Storage Format |
|-----------|------------|-------|----------------|
| `List<String>` | `TEXT` | `TEXT` | Comma-separated: `"a,b,c"` |
| `String[]` | `TEXT` | `TEXT` | Custom separator: `"a\|b\|c"` |
| `List<Integer>` | `TEXT` | `TEXT` | Numbers as text: `"1,2,3"` |

```java
@ArrayColumn(separator = ",")    // Default
private List<String> tags;       // → "tag1,tag2,tag3"

@ArrayColumn(separator = "|")    // Custom separator
private String[] categories;     // → "cat1|cat2|cat3"
```

### Enum Storage Strategies

| Strategy | Storage Type | PostgreSQL | MySQL | When to Use |
|----------|--------------|------------|-------|-------------|
| `STRING` | `VARCHAR` | ✅ | ✅ | Human-readable, refactor-safe |
| `ORDINAL` | `INTEGER` | ✅ | ✅ | Compact storage, order matters |
| `CODE` | `VARCHAR` | ✅ | ✅ | Custom codes, backward compatibility |

```java
// STRING mode - stores "ACTIVE", "INACTIVE"
@EnumColumn(EnumColumn.EnumType.STRING)
private Status status;

// ORDINAL mode - stores 0, 1, 2, 3  
@EnumColumn(EnumColumn.EnumType.ORDINAL)  
private Priority priority;

// CODE mode - stores custom codes "SALE", "MKTG"
@EnumColumn(EnumColumn.EnumType.CODE)
private Department dept;  // Requires getCode() method
```

### UUID Handling

| Database | Storage | Format | Performance |
|----------|---------|---------|-------------|
| PostgreSQL | `UUID` | Native binary | ✅ Optimal |
| MySQL | `VARCHAR(36)` | String format | ⚠️ Larger storage |

```java
@UUID(autoGenerate = true)
@Column("entity_uuid")
private String uuid;  // Auto-generated on insert

@UUID(autoGenerate = false)  
private String manualUuid;  // You provide the value
```

## Requirements

- Java 8+
- JDBI 3.x
- Jackson (for JSON handling)
- Database: PostgreSQL, MySQL, or any JDBI-supported database

## Getting Started

1. Add your database dependency (PostgreSQL/MySQL driver)
2. Configure JDBI with your database
3. Create your entity classes with annotations
4. Extend CRUD class for each entity
5. Start using the generated CRUD operations!

The library handles all the tedious SQL generation and type conversions automatically, letting you focus on your business logic.